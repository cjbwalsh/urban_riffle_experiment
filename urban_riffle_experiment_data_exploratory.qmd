---
title: "Suction sampler data exploratory analysis"
format: html
editor: visual
bibliography: references.bib
---

## Introduction

This document has been initially drafted by Chris Walsh as a primer for Dana Dekkers: an introduction to the available quantitative Monbulk Creek macroinvertebrate data collected using a suction sampler similar to the one to be used in the Monbulk Creek study, and an introduction to R code (and quarto documents) for using the data.

## Loading data

I saved the data from an habitat experiment in 9 streams in eastern Melbourne into a spatial lite database (.gpkg) file (see `urban_riffle_exp_data_compilation.qmd`). gpkg format permits a mix of spatial and non-spatial tables. For non-spatial tables, it's easier to stick with excel or csv files.

```{r}
#| echo: true
#| warning: false
#| message: false

library(RSQLite)
source("https://tools.thewerg.unimelb.edu.au/documents/mwstr/mwstr_functions.R")
source("https://tools.thewerg.unimelb.edu.au/data/mwbugs/bugDatabaseFunctions.R")

#connect to the gpkg database
re_db <- dbConnect(SQLite(),
          dbname="~/uomShare/wergStaff/ChrisW/git-data/urban_riffle_experiment/urban_riffle_experiment_data.gpkg")
sites <- sf::st_read(re_db, "sites")
samples <- dbReadTable(re_db,"samples")
biota <- dbReadTable(re_db,"biota")
taxonomy <- dbReadTable(re_db,"taxon_tab")
taxon_all <- dbReadTable(re_db,"taxon_all")
metadata <- dbReadTable(re_db,"metadata")

```

## Some example code for maps

Here is some example code for reading tables from the `mwstr` stream network database (see @kunapo_etal_2020). Data can be accessed from the mwbugs database [@walsh_etal_2020] (and other databases) using similar SQL commands. (I can show you some strategies for disassembling code to help you understand what is going on.)

```{r}
#| label: fig-experiment_map
#| echo: true
#| fig-width: 5
#| fig-height: 6.5
#| warning: false
#| message: false
#| fig-cap: "Map of experimental sites (6 sites in which riffles were constructed and 3 control sites) and their catchments.  The grey shading indicates impervious coverage in 2004."

#Streams for creating a map sqlQuery is a function I wrote, stored in mwstr_functions.R, loaded above
streams <- sqlQuery("SELECT * FROM streams WHERE sampleable = 1;", "mwstr")
# Catchments of the nine sites (note the cats table is huge, so you need to specify just those catchments you're interested in - hence the paste0 command...)
sites$reach <- substr(sites$sitecode, 1, nchar(sites$sitecode) - 1)
cats <- sqlQuery(paste0("SELECT * FROM cats WHERE reach IN ('",
                        paste(sites$reach, collapse = "', '"), "');"), "mwstr")
coast <- sqlQuery("SELECT * FROM coast;", "mwstr")
# impervious coverage raster
ia <- terra::rast("~/uomShare/wergStaff/ChrisW/git-data/mwstr/mwstr_v12_corrections/rasters_v13/r_imp_2004.tif")
# crop to area to be plotted (placing a 10 km buffer around the cats polygons)
ia <- terra::crop(ia, terra::ext(sf::st_buffer(cats,1e4)))

#Colour sites by experimental treatment (see: https://colorbrewer2.org/)
sites$col <- 
  RColorBrewer::brewer.pal(3,"Dark2")[match(sites$exp_treatment == "riffle",0:1)]

par(mar = c(0,0,0,0))
plot(cats$geometry, pch = 21, border = "white")
terra::plot(ia, col = gray(0.75), legend = FALSE, axes = FALSE, add = TRUE)
plot(streams$geometry, col = "darkblue", add = TRUE)
plot(cats$geometry, border = sites$col[match(cats$reach,sites$reach)], 
     lwd = 2, add = TRUE)
plot(coast$geometry, lwd = 2, add = TRUE)
plot(sites$geom, pch = 21, bg = sites$col, add = TRUE) # so that the sites are on top
box()
legend("bottomleft", pch = 21, pt.bg = RColorBrewer::brewer.pal(3,"Dark2"),
       legend = c("Control","Riffle"))
```

## Preparing macroinvertebrate data for analysis

One of the experiment's control sites was on Monbulk Creek. The site was not far upstream of the confluence with Ferny Creek. While this site is more urban now, when the data were collected it was probably of a similar level of urbanization as sites near Birdsland are today. The data area therefore a useful model set to plan your sampling program (although note that all samples are from run/pool habitat, and riffle samples are likely to contain different abundances).

The data are saved in a format consistent with the mwbugs database [@walsh_etal_2020], and will ultimately be added there. The three core tables are:

-   sites: information about the location and purpose of each site

-   samples: information about each individual suction sample unit taken from each site (with each sample being linked to the sites table by its sitecode). Importantly, this table includes a field `subsample_perc`, the proportion of the subsample that was sorted.

-   biota: the taxa and the count of each taxon in the subsample. Each taxon has a taxoncode, which is very useful for taxonomic lumping (see below), and is linked to two tables in this dataset (`taxon_all`, which lists all taxa in the mwbugs database, in turn linked to other taxonomy tables from which a summary taxonomy table like `taxonomy` can be generated.

To inspect each of these tables, you can either click on them in the "Environments" tab (top right pane of RStudio) or use the head (or tail) command in the console to see the first 6 (or however many you specify) rows, e.g.:

`head(biota, 6)`

To subset the samples and biota tables to get all samples taken from the Monbulk Creek site, and find out how many samples were taken:

```{r}
mnb_samples <- samples[samples$sitecode == "MNB_3032g",]
# I looked up the sitecode for Monbulk Creek in the sites table
nrow(mnb_samples)
mnb_biota <- biota[biota$smpcode %in% mnb_samples$smpcode,]
```

There are 45 suction samples from Monbulk Creek in the database. The samples were taken on six different occasions over five years, and we can and should explore any temporal trends (and trends within the site related to depth or velocity for which we have data), but for now, let's just treat them as 45 replicates to get a feel for variability in abundances (and ultimately biomass). Here we inspect the records in the biota table for the (say) first sample in mnb_samples (ordering by taxoncode to get the biota in a sensible taxonomic order).

```{r}
sample1 <-  
  mnb_biota[mnb_biota$smpcode == mnb_samples$smpcode[1],
        c("smpcode","taxoncode","shortcode","taxon","count")]
# There are other fields, but these are the important ones for now
sample1 <- sample1[order(sample1$taxoncode),]
sample1
```

There are `r nrow(sample1)` taxa recorded in this one sample of wide-ranging abundance, but note that some of the taxa originally recorded have been lumped to a single taxoncode (e.g. adult and larval Austrolimnius should be considered a single taxon. To consolidate the sample data into a set with a single record per taxoncode,

```{r}
sample1_agg <- aggregate(sample1["count"], 
                         by = list(smpcode = sample1$smpcode, 
                                   taxoncode = sample1$taxoncode,
                                   shortcode = sample1$shortcode), FUN = sum)
# And retrieve standard name for taxon from taxon_all table
sample1_agg$taxon <- taxon_all$taxon[match(sample1_agg$shortcode, taxon_all$shortcode)]
sample1_agg
```

... reducing the sample to `r nrow(sample1_agg)`. The same command can be applied to the full biota table to ensure no duplicate taxoncodes, reducing the number of records in biota from 6452 to 6370.

Now, because most samples have been subsampled, we can only estimate the true total number of each taxon in the sample. At the analysis stage we should incorporate subsampling uncertainty in the estimates of the total numbers, but for initial exploratory analysis we could make a naive estimate by dividing the count in the subsample by the subsample proportion.

```{r}
mnb_biota <- aggregate(mnb_biota["count"], 
                         by = list(smpcode = mnb_biota$smpcode, 
                                   taxoncode = mnb_biota$taxoncode,
                                   shortcode = mnb_biota$shortcode), FUN = sum)
# And retrieve standard name for taxon from taxon_all table
mnb_biota$taxon <- mnb_biota$taxon[match(mnb_biota$shortcode, taxon_all$shortcode)]
mnb_biota$ss <- mnb_samples$subsample_perc[match(mnb_biota$smpcode,mnb_samples$smpcode)]/100
mnb_biota$naive <- round(mnb_biota$count/mnb_biota$ss)
```

At this stage, I usually produce a taxon-by-sample matrix and export it to excel to inspect for any potential errors (in excel, you can format cell widths \[for header row, format-cell-align - rotate 90 deg\], and set preferences \[excel-preferences-view\] so that zero values show as blanks, which makes data-checking easier).

```{r}
mnb_biota_ct <- ct(rows = mnb_biota$shortcode,
                   cols = mnb_biota$smpcode, 
                   values = mnb_biota$naive)
mnb_biota_ct <- data.frame(taxon = taxon_all$taxon[match(row.names(mnb_biota_ct),
                                                         taxon_all$shortcode)],
                           mnb_biota_ct)
WriteXLS::WriteXLS(mnb_biota_ct,
"~/uomShare/wergStaff/ChrisW/git-data/urban_riffle_experiment/mnb_biota_ct.xlsx", 
row.names = TRUE)
```

We can further aggregate the data into higher taxonomic levels easily using the taxoncodes (First 2 characters = Order or higher group; First 4 characters = Family; First 6 characters = Genus). So, to aggregate our example sample to Order or higher group, and produce a new taxon-by-sample table for checking...

```{r}
mnb_biota$rank1 <- substr(mnb_biota$taxoncode,1,2)
mnb_biota_r1 <- aggregate(mnb_biota[c("count","naive")], 
                         by = list(smpcode = mnb_biota$smpcode, 
                                   shortcode = mnb_biota$rank1), FUN = sum)
mnb_biota_r1$taxon <- taxon_all$taxon[match(mnb_biota_r1$shortcode, taxon_all$shortcode)]
mnb_biota_r1[mnb_biota_r1$smpcode == mnb_samples$smpcode[1],]
mnb_biota_r1_ct <- ct(rows = mnb_biota_r1$shortcode,
                   cols = mnb_biota_r1$smpcode, 
                   values = mnb_biota_r1$naive)
mnb_biota_r1_ct <- data.frame(taxon = taxon_all$taxon[match(row.names(mnb_biota_r1_ct),
                                                         taxon_all$shortcode)],
                           mnb_biota_r1_ct)
WriteXLS::WriteXLS(mnb_biota_r1_ct,
"~/uomShare/wergStaff/ChrisW/git-data/urban_riffle_experiment/mnb_biota_r1_ct.xlsx", 
row.names = TRUE)
```

## Modelling abundance distributions

Thinking about your primary interest in biomass, given the uncertainty in abundance measures (particularly the uncertainty around zero counts in subsamples), I anticipate it will be better to model abundance data and then apply estimates of biomass to each taxon. (This will become clearer once you are actively modelling.)

You will need to consider which of the taxa are of interest to your question. I suspect taxa such as Nematoda and microcrustracea (OG, OH, OI) are not of interest and could be omitted. Gastropoda (dominated by the invasive New Zealand mud snail, *Potampopyrgus antipodarum*) is the most abundant group, but I suspect that these are not an important element of platypus diet. (Am I wrong?). Let's start by inspecting the distributions of some other taxa of varying abundance in these samples.

The distributions of estimated total counts of these high-level taxa were highly skewed, and not well characterised by Poisson distributions. They are however, well characterised by negative binomial distributions (Figure 2). <!--# crossref not working for me right now... -->

```{r}
#| label: fig-rank1_dists
#| echo: true
#| fig-width: 7
#| fig-height: 2.5
#| warning: false
#| message: false
#| fig-cap: "Observed (pink bars) distribution of abundances of A) Diptera, B) Ephemeroptera and C) Trichoptera in 45 suction samples from Monbulk Creek.  1000 modelled abundances fitted to a negative binomial distribution of each group are shown in grey."

layout(matrix(c(4,1,2,3,0,5,5,5), 2,4,byrow = TRUE),
       heights = c(12,2), widths = c(2,12,12,12))
par(mar = c(4,4,1,1))
# Diptera
qd <- as.vector(t(mnb_biota_r1_ct[row.names(mnb_biota_r1_ct) == "QD",-1]))
qd_nbinom <- fitdistrplus::fitdist(qd,"nbinom")
qd_modelled <- rnbinom(1000, mu = qd_nbinom$estimate[2], size = qd_nbinom$estimate[1])
hist(qd_modelled, breaks = seq(0,plyr::round_any(max(qd_modelled),5,f = ceiling),5), 
     col = scales::alpha("black",0.25), freq = FALSE,
     main = "A. QD: Diptera",xlab = "",ylim = c(0,0.05))
hist(qd, breaks = seq(0,plyr::round_any(max(qd),5),5), 
     col = scales::alpha("red",0.25),freq = FALSE, add = TRUE)

# Ephemeroptera
qe <- as.vector(t(mnb_biota_r1_ct[row.names(mnb_biota_r1_ct) == "QE",-1]))
qe_nbinom <- fitdistrplus::fitdist(qe,"nbinom")
qe_modelled <- rnbinom(1000, mu = qe_nbinom$estimate[2], size = qe_nbinom$estimate[1])
hist(qe_modelled, breaks = seq(0,plyr::round_any(max(qe_modelled),5,f = ceiling),5), 
     col = scales::alpha("black",0.25), freq = FALSE,
     main = "B. QE: Ephemeroptera",xlab = "",ylim = c(0,0.15))
hist(qe, breaks = seq(0,plyr::round_any(max(qe),5),5), 
     col = scales::alpha("red",0.25),freq = FALSE, add = TRUE)

# Trichoptera
qt <- as.vector(t(mnb_biota_r1_ct[row.names(mnb_biota_r1_ct) == "QT",-1]))
qt_nbinom <- fitdistrplus::fitdist(qt,"nbinom")
qt_modelled <- rnbinom(1000, mu = qt_nbinom$estimate[2], size = qt_nbinom$estimate[1])
hist(qt_modelled, breaks = seq(0,plyr::round_any(max(qt_modelled),5, f = ceiling),5), 
     col = scales::alpha("black",0.25), freq = FALSE,
     main = "C. QT: Trichoptera",xlab = "", ylim = c(0,0.15))
hist(qt, breaks = seq(0,plyr::round_any(max(qe),5),5), 
     col = scales::alpha("red",0.25),freq = FALSE, add = TRUE)

```

Therefore, for these three taxa distributions of their abundances could be simulated using the `rnbinom()` function, with the following parameters, derived using the function `fitdistrplus::fitdist` using maximum likelihood (\@tbl_nbinom_params).

```{r}
#| echo: false
#| label: tbl-nbinom_params
#| tbl-cap: "Best-fit parameters for modelling abundance Diptera (QD), Ephemeroptera (QE), and Trichoptera (QT) in suction samples from Monbulk Creek as negative binomial distributions."

nbinom_params <- cbind(qd_nbinom$estimate,qe_nbinom$estimate,qt_nbinom$estimate)
nbinom_params <- data.frame(parameters = c("size","mu"),
                            nbinom_params)
names(nbinom_params)[-1] <- c("QD","QE","QT")
ft <- flextable::regulartable(nbinom_params)
ft <- flextable::colformat_double(ft, i = 1, digits = 2)
ft <- flextable::colformat_double(ft, i = 2, digits = 1)
ft
```

With that distributional groundwork, we are well placed to simulate data to plan a monitoring program. Let us discuss!
