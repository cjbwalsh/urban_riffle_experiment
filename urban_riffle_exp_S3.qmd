---
title: "Appendix S3. Methods and code for fitting and assessing the models"
author: "Christopher J Walsh, J Angus Webb, Daniel C Gwinn, and Peter F Breen"
format: docx
editor: visual
bibliography: references.bib
csl: journal-of-applied-ecology.csl
---

```{r}
#| echo: false
#| message: false
#| error: false
#| include: false

######### READ THIS CHUNK BEFORE PROCEEDING ########
# If you want to run the 'eval: false' chunks in this document, you will need to 
# adjust the following directory for keeping large files
model_fit_dir <- 
    "~/uomShare/wergStaff/ChrisW/git-data/urban_riffle_experiment/model_fits/"

## Packages required for evaluated chunks
requiredPackages <- c("osfr","dplyr","flextable","rio")
lapply(requiredPackages, require, character.only = TRUE)
## Packages required for 'eval: false' chunks: WriteXLS and cmdstanr 
## (See chunk 'sample_env_models')

## Check if there is a 'data' directory. If not make one
if(!"data" %in% dir()){dir.create("data")}
## While in review, the 3 large data files are in a private OSF repository
## They can be downloaded to the data directory using this view-only link
## https://osf.io/cms84/?view_only=256efadc4a124bcb96c6483226ef3a23
## When the repository is public, the following will allow automatic download
# ## The following checks for large data files, and if absent downloads them 
# ## from the OSF repository to the data directory
# if(!"wq_data_compiled.xlsx" %in% dir("data")){
# wq_files <- osf_retrieve_node("cms84") %>% osf_ls_files()
# osf_download(wq_files, path = "data")
# }
```

The first part of this document details the specifications and code used to estimate the model of taxon abundance in the main paper. The second part assesses the model fit.

## 1. Model specification

The dataset for all models consisted of 3--4 sample units, collectively termed a sample, taken from each of 9 sites (6 experimental in which riffles were constructed and 3 controls) on each of 6 occasions (2 before, B; 2 in the first year after, A1; and 2 5-6 years after riffle construction, A2). Each sample was taken in either autumn (spring = 0) or spring (spring = 1).  The sites spanned an urban gradient represented by (log-transformed and scaled) effective imperviousness I.

We estimated the posterior distributions of parameters in the multi-taxon model of taxon abundances and the models of environmental variables (depth, velocity and $\Phi$, particle size) in the sample units using the Markov chain Monte-Carlo (MCMC) sampler of Stan [@carpenter_etal_2017], calling Stan from R using the library `cmdstanr` [@gabry_cesnovar_2022].

We used uninformative prior distributions for fixed effect parameters (BA, CI, I, and their interactions, and spring) and weakly informative prior distributions for the random variable parameters.  We modelled the environmental variables (transformed as necessary and scaled, Table 1) as normal distributions with standard deviation (sd) having a prior half-normal distribition (mean 0, sd 1). In the multi-taxon model, we modelled count of each taxon in each sample unit as a negative binomial distribution with a dispersion parameter ($\phi$) having a normal prior distribution (restricted to values > 0, mean 1, sd 1).

```{r}
#| label: tbl-env_vars
#| echo: false
#| tbl-cap: "The transformations of the six environmental variables reported in the paper used to model their response to urban riffle construction. Phi is the negative log (base 2) of the smallest diameter of a sediment particle. The correlation coefficient, R, of the relationship between the mean (transformed) observed values of each variable in each sample and the values predicted by the models, and the slope of the regression between observed and predicted, are also indicated."

gofs <- read.csv("small_data/env_gofs.csv")
gofs <- gofs[gofs$model != "max_phi",]
ft <- data.frame(Variable = c("Variance of depth (m)", "Mean of depth (m)", 
                              "Variance of velocity (m/s)", "Mean of Velocity (m/s)",
                              "Minimum Phi", "Median Phi"),
                 Transformation = c("log(x + 0.00175)", "log(x)", 
                                    "log(x + 0.0007442)", "log(x)","None","None"),
                 R = round(sqrt(gofs$oe_r_squ),3), 
                 Slope = round(gofs$oe_slope,2))
  ft <- flextable::regulartable(ft)
  ft <- flextable::align(ft, align = "left", part = "all")
  ft <- flextable::valign(ft, valign = "top", part = "all")
  ft <- flextable::font(ft,fontname = "Helvetica", part = "all")
  ft <- flextable::fontsize(ft, size = 10, part = "all")
  ft <- flextable::padding(ft, padding.top = 2,  padding.bottom = 2, part = "all")
  ft <- flextable::autofit(ft)
  ft <- flextable::width(ft, width = dim(ft)$widths*6.5 /(flextable_dim(ft)$widths))
ft
```

In all models, we formulated $\beta$ parameters (of fixed effects) as random effects drawn from community-level hyper-distributions with the mean parameters specified as diffuse normal distributions (mean 0, sd 5) and, for the multi-taxon model, the parameters for each species were drawn from a multivariate normal distribution with a covariance matrix that describes the residual associations among species. The hyperprior correlation matrix ($\Omega$) had an LKJ prior with shape 2, and scale with an exponentially distributed prior with rate 1 [@stan_dev_team_2022]. For all models, the random-effect parameters for site ($\theta_{s}$), time ($\theta_{t}$) and sample ($\theta_{s,t}$) were drawn from normal hyper-distributions, with mean 0 and sd with a half-normal prior distribution (mean 0, sd 1). 

For all models, we drew inference from 4 unthinned chains, taking 2,600 posterior samples from each chain and discarding the first 2,000 for the models of environmental variables, and 5,000 samples discarding the first 1,000 for the multi-taxon model. The retained samples were sufficient to ensure bulk and tail effective sample sizes of at least 100 per chain for all parameters. We diagnosed convergence of each model by visually inspecting the MCMC chains for adequate mixing and stationarity, and ensured that the diagnostic tests for zero-divergent transitions, zero cases of saturated tree-depth, Gelman-Rubin statistic ($\hat{R}$) < 1.1, and Bayesian Fraction of Missing Information >0.3, were satisfied.

### Models of environmental variables

The Before-After-Control-Impact effects on environmental variables were modelled assuming a normal distribution for each (appropriately transformed, Table 1) environmental variable. The Stan code for the model, `normal_rand_sa_si_t_fixedmatrix-baci.stan`, is reproduced below, with annotations defining variables and parameters, and explaining model components. Below that is the code used to load the data, run, check and evaluate the model for each variable, and produce output objects used to produce figures in the manuscript. Running all models took ~3.5 min.

#### Stan code

```{stan output.var = "env_mod"}
#| echo: true
#| eval: false

data {
  int<lower=0> n_obs;       // Number of observations (sample-units, s-u)
  int<lower=1> n_site;      // Number of sites
  int<lower=1> n_sample;    // Number of samples  (combinations of t_no, site_no)
  int<lower=1> n_pred;      // Number of predictor variables
  int<lower=1> n_t;         // Number of sampling occasions
  matrix[n_obs,n_pred] u;   // group predictors (model matrix) 
  array[n_obs] real y;      // Normally-distributed response variable
  array[n_obs] int site_no; // Site number
  array[n_obs] int samp_no; // Sample number (vectorised [t_no, site_no])
  array[n_obs] int t_no;    // sampling occasion number
}
parameters {
  vector[n_pred] gamma;        // beta parameters of fixed effects in u
  vector[n_site] a_s_raw;      // raw coefficient of random site effect 
  vector[n_t] a_t_raw;         // raw coefficient of time effect 
  vector[n_sample] a_st_raw;   // raw coefficient of random sample effect 
                               // (1 sample per site_no per t_no)
  // see reparameterizations below for explanation of these raw coefficients
  real<lower=0> sigma_s;       //sd of hyperdistribution of a_ss among taxa
  real<lower=0> sigma_t;       //sd of hyperdistribution of a_ts among taxa
  real<lower=0> sigma_st;      //sd of hyperdistribution of a_sts among taxa
  real<lower=0> sigma;         //sd of mu
}
transformed parameters {
  vector[n_obs] mu;          // Log total count
  vector[n_site] a_s;        // coefficient of random site effect
  vector[n_t] a_t;           // Coefficient of time effect 
  vector[n_sample] a_st;     // coefficient of random site effect
  
  a_s =  sigma_s * a_s_raw;  
  a_t =  sigma_t * a_t_raw;  
  a_st =  sigma_st * a_st_raw;  
// with (e.g.) a_s_raw ~ std_normal(), this implies a_s ~ normal(0, sigma_s)
// See https://mc-stan.org/docs/stan-users-guide/reparameterization.html

   for(i in 1:n_obs){
       //The linear model
  mu[i] = a_s[site_no[i]] + a_t[t_no[i]]  +  a_st[samp_no[i]] +  
          u[i,] * gamma; 
      }
}

model {
  // Priors
   a_s_raw ~ std_normal();
   a_t_raw ~ std_normal();  
   a_st_raw ~ std_normal();
   to_vector(gamma) ~ normal(0,5);
   sigma_s ~ normal(0,1);  
   sigma_t ~ normal(0,1); 
   sigma_st ~ normal(0,1);
   sigma ~ normal(0,1);

 // Likelihood
  for (i in 1 : n_obs) {
    target += normal_lpdf(y[i] | mu[i], sigma);
  }
}

```

#### Assembling data and model sampling: R code

The following code loads the above stan model, and then looping through the 7 environmental variables (including maximum $\Phi$, not presented in the manuscript), assembles the data for each model (reducing the data, where necessary to account for differences in the spread of the few missing data), samples the model, recording sampling diagnostics of sample, the model object and `cmdstanr` csv files holding the posterior draws (a method which requires less RAM than saving all draw data in the model object). The sampling diagnostics are saved in a single table `univar_diagnostics.csv`.

```{r}
#| label: assemble_data
#| echo: true
#| message: false
#| error: false

# load and check cmdstanr package
library(cmdstanr) # see https://mc-stan.org/cmdstanr/articles/cmdstanr.html
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
# Set random seed to ensure reproducible results
rand_seed = 9430570 

source("misc_functions.R") # for ct and unscale functions
#import tables "sites","samples","biota","taxon_all","taxa","higher_taxa","metadata"
dat_list <- rio::import_list("data/urban_riffle_experiment_data_for_model.xlsx")
list2env(dat_list,globalenv())
# The dataset contains samples from the segments upstream (U) and downstream (D) 
# of the riffle (putative or real) in each site for trip 1-4 (out of 6).  Given 
# the small effects in the 'riffle' segments (M), and the incomplete processing 
# of the U and L segments, only M samples in the analysis.
samples$seg <- substr(samples$old_samplecode,nchar(samples$old_samplecode)-1,
                      nchar(samples$old_samplecode)-1)
samples <- samples[samples$seg == "M",]

# Assemble random predictors (site_no, sample_no, t)
sites <- sites[order(sites$exp_treatment,sites$ai),]
sites$site_no <- 1:nrow(sites)
samples$site_no <- sites$site_no[match(samples$sitecode,sites$sitecode)]
samples$sample <- substr(samples$old_samplecode,1,nchar(samples$old_samplecode)-1)
sample_nos <- data.frame(sample = unique(samples$sample))
sample_nos$sample_no <- 1:nrow(sample_nos)
samples$sample_no <- sample_nos$sample_no[match(samples$sample, sample_nos$sample)]
samples$t_no <- as.numeric(substr(samples$old_samplecode, 1,1))

# Assemble fixed predictors (a1,a2, ci, ba1ci, ba2ci, i, ba1cii, ba2cii, spring) into a matrix, u
samples$ba <- as.numeric(as.numeric(substr(samples$old_samplecode,1,1)) %in% c(3,4)) 
samples$ba[as.numeric(as.numeric(substr(samples$old_samplecode,1,1))) %in% c(5,6)] <- 2
samples$ba <- factor(samples$ba)
# a1 and a2 are the two after periods treated as categories with b as a reference
samples$ci <- as.numeric(sites$exp_treatment[match(samples$sitecode,sites$sitecode)] == "riffle") 
# 0 = control, 1 = riffle
samples$ai <- sites$ai[match(samples$sitecode, sites$sitecode)]
i_scaled <- scale(log10(samples$ai*100 + 0.1))
samples$i <- as.vector(i_scaled)
samples$spring <- as.integer(substr(samples$old_samplecode,1,1) %in% c(1,3,5))
u <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i + spring, data = samples)
```


```{r}
#| label: sample_env_models
#| echo: true
#| message: false
#| error: false
#| eval: false

# Assemble transformed and scaled environmental predictors
ys <- list(
  depth_m_var = as.vector(scale(log(samples$depth_m_var + 1.75e-04))),
# min(samples$depth_m_var[!is.na(samples$depth_m_var) & samples$depth_m_var > 0]) 
           # 0.0007442
  depth_m_mean = as.vector(scale(log(samples$depth_m_mean))),
  vel_m_s_var = as.vector(scale(log(samples$vel_m_s_var + 0.0007442))),
# min(samples$vel_m_s_var[!is.na(samples$vel_m_s_var) & samples$vel_m_s_var > 0]) 
# 0.0007442
  vel_m_s_mean = as.vector(scale(log(samples$vel_m_s_mean))), 
  min_phi = as.vector(scale(samples$min_phi)),
  max_phi = as.vector(scale(samples$max_phi)),
  med_phi = as.vector(scale(samples$med_phi))
)

y_transform_pars <- data.frame(stat = names(ys)[1:length(ys)],
                               log = c(rep(TRUE,4),rep(FALSE,3)), 
                               log_add = c(1.75e-04,0,0.0007442,0,NA,NA,NA))

# Check stan model is up-to-date: if not, compile.
env_mod <- cmdstan_model("normal_rand_sa_si_t_fixedmatrix_baci.stan", pedantic = TRUE) 

# system.time({
univar_diagnostics <-
  data.frame(model = NA,divergences = NA,max_treedepth_exceedences = NA,
             min_bfmi = NA,max_bfmi = NA,max_rhat = NA,min_ess_bulk = NA,
             min_ess_tail = NA)[0,]

# Loop through the 7 environmental variables (including max Phi, not presented)
for(i in 1:length(ys)){
# remove NAs
  yi <- names(ys)[i]
samplesi <- samples[!is.na(samples[,yi]),]
ui <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, data = samplesi)
# and for sample no (as there a variable missing samples)
sample_nos <- data.frame(sample = unique(samplesi$sample))
sample_nos$sample_no <- 1:nrow(sample_nos)
samplesi$sample_no <- sample_nos$sample_no[match(samplesi$sample, sample_nos$sample)]

# Data list for Stan
sdata <- list(n_obs = nrow(samplesi),
              n_site = nrow(sites),
              n_sample = nrow(sample_nos),
              n_pred = ncol(ui),
              n_t = max(samplesi$t),
              site_no = samplesi$site_no,
              samp_no = samplesi$sample_no,
              t_no = samplesi$t,
              u = ui,
              y = ys[[i]][match(samplesi$smpcode,samples$smpcode)]
)

stanfit_i <- env_mod$sample(data = sdata,
                        seed = rand_seed, chains = 4,
                        parallel_chains = 4, 
                        iter_warmup = 2000,
# adjustments to Stan settings to meet diagnostic criteria
                        adapt_delta = ifelse(names(ys[i]) %in% c("min_phi","max_phi","med_phi","vel_m_s_var","vel_m_s_mean"), 0.98, 0.8),
                        max_treedepth = ifelse(names(ys[i]) == "depth_m_mean", 12, 10),
                        iter_sampling = 600, 
                        refresh = 100)
# #  save csv files rather than the model object to use less RAM
stanfit_i$save_output_files(
  dir = model_fit_dir,
  basename = paste0("fit_riffle_baci_", names(ys)[i]), timestamp = FALSE, random = FALSE)
stanfit_i$sampler_diagnostics()
saveRDS(stanfit_i, file = paste0(model_fit_dir,"fit_riffle_baci_", names(ys)[i], ".rds"))
stanfit_i$diagnostic_summary()
summ <- stanfit_i$summary() 
univar_diagnostics <- rbind(univar_diagnostics, data.frame(model = names(ys)[i],
                                 divergences = sum(stanfit_i$diagnostic_summary()$num_divergent),
                                 max_treedepth_exceedences = sum(stanfit_i$diagnostic_summary()$num_max_treedepth),
                                 min_bfmi = min(stanfit_i$diagnostic_summary()$ebfmi),
                                 max_bfmi = max(stanfit_i$diagnostic_summary()$ebfmi),
                                 max_rhat = max(summ$rhat,na.rm=TRUE),
                                 min_ess_bulk = min(summ$ess_bulk,na.rm=TRUE),
                                 min_ess_tail = min(summ$ess_tail,na.rm=TRUE)))
}
write.csv(univar_diagnostics, "small_data/univar_diagnostics.csv", row.names = F)
# }) # ~3.5 min
```

The following chunk loops through the seven environmental variables, loading the model object for that variable and extracting the posterior distributions of the model parameters.  The parameter distributions are used to calculate a prediction for every sample in the data set. We compared these predictions to the observed mean values to assess model fit.  

The predictors were assembled as the table, `predx`: the unique set of predictors to permit prediction the mean value of the variable in each of the samples of the study: a data.frame with 14 predictors (columns) and 53 combinations of predictor values (one for each sample).

`predy_draws` is a data.frame with 51--53 columns (matching predx rows, varied because of two samples missing substrate data) and 2400 rows (600 samples times 4 chains): the posterior distribution of the predicted mean abundance for each `predx` value. The chunk also calculates resulting goodness of fit measures reported below (and in Table 1).

```{r}
#| label: env_gofs
#| echo: true
#| message: false
#| error: false
#| eval: false

system.time({
gofs <-data.frame(model = NA, oe_r_squ = NA, oe_slope = NA, pred_95 = NA, nrowpredx = NA)[0,]
for(i in 1:length(ys)){
# remove NAs
  yi <- names(ys)[i]
  # load model object and assemble sdata as above
  stanfit_i <- readRDS(paste0(model_fit_dir,"fit_riffle_baci_",names(ys)[i], ".rds"))
  samplesi <- samples[!is.na(samples[,yi]),]
  ui <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, data = samplesi)
  sample_nos <- data.frame(sample = unique(samplesi$sample))
  sample_nos$sample_no <- 1:nrow(sample_nos)
  samplesi$sample_no <- sample_nos$sample_no[match(samplesi$sample, sample_nos$sample)]
  sdata <- list(n_obs = nrow(samplesi), n_site = nrow(sites),
                n_sample = nrow(sample_nos),n_pred = ncol(ui),
                n_t = max(samplesi$t),site_no = samplesi$site_no,
                samp_no = samplesi$sample_no,t_no = samplesi$t,u = ui,
                y = ys[[i]][match(samplesi$smpcode,samples$smpcode)])
  # Extract the posterior distributions of the model parameters
  drawsi <- as.data.frame(stanfit_i$draws(format = "df", 
                          variables = c("a_s","a_st","gamma", "a_t",
                                        "sigma_s","sigma_t","sigma_st","sigma"))) 
  predx <- unique(cbind(samplesi[c("sample","site_no","sample_no","t_no")],ui))
  temp <- aggregate(sdata$y, by = list(sample = samplesi$sample),FUN = mean)
  predx$x <- temp$x[match(predx$sample, temp$sample)]
    predy_draws <-
      drawsi[grep("a_s",names(drawsi))][match(predx$site_no, 1:sdata$n_site)] +
      drawsi[grep("a_t",names(drawsi))][match(predx$t, 1:sdata$n_t)] +
      drawsi[grep("a_st",names(drawsi))][match(predx$sample_no, 1:sdata$n_sample)] +
      drawsi[,"gamma[1]"] %*% t(predx$`(Intercept)`) +
      drawsi[,"gamma[2]"] %*% t(predx$ba1) +
      drawsi[,"gamma[3]"] %*% t(predx$ba2) +
      drawsi[,"gamma[4]"] %*% t(predx$ci) +
      drawsi[,"gamma[5]"] %*% t(predx$i) + 
      drawsi[,"gamma[6]"] %*% t(predx$`ba1:ci`) +
      drawsi[,"gamma[7]"] %*% t(predx$`ba2:ci`) +
      drawsi[,"gamma[8]"] %*% t(predx$`ba0:ci:i`) + 
      drawsi[,"gamma[9]"] %*% t(predx$`ba1:ci:i`) +
      drawsi[,"gamma[10]"] %*% t(predx$`ba2:ci:i`) 
names(predy_draws) <- predx$sample
meansi <- apply(predy_draws, 2, FUN = mean)
cisi <- apply(predy_draws, 2, quantile, probs = c(0.025,0.975))
lmi <- lm(meansi ~ predx$x)
gofsi <- data.frame(model = names(ys)[i],
                   oe_r_squ = summary(lmi)$adj.r.squared,
                   oe_slope = lmi$coefficients[2],
                   pred_95 = 0,
                   nrowpredx = ncol(predy_draws))
for(j in 1:nrow(predx)){
  gofsi$pred_95 <- gofsi$pred_95 + 
    as.numeric(findInterval(predx$x[j], cisi[,j]) == 1)
  #This adds one if the observed value is between the two CIs
}
gofsi$pred_95 <- gofsi$pred_95/nrow(predx)
gofs <- rbind(gofs, gofsi)
}
write.csv(gofs, "small_data/env_gofs.csv", row.names = FALSE)
})  # 6 s
```

The following code extracts the posterior distribution of mean abundance for each taxon in samples across the gradient of imperviousness for all combinations of *ba* = 0, 1 or 2; *ci* = 0 or 1; *I* = minimum and maximum values in dataset (=4% and 32% EI); spring = 0 (i.e. autumn), omitting random sample, site and t errors (For counterfactual plots used in the paper, demonstrating effect of riffle emplacement under different levels of urban impact), and the primary differences of interest in the BACI design:

1.  (control minus impact before \[B\]) - (control minus impact in first year after \[A1\]) for low (minimum) *I*

2.  (control minus impact before \[B\]) - (control minus impact 5-6 y after \[A2\]) for low *I*

3.  (control minus impact before \[B\]) - (control minus impact in first year after \[A1\]) for high *I*

4.  (control minus impact before \[B\]) - (control minus impact 5-6 y after \[A2\]) for high *I*

It saves a table `env_diff_summs.csv` used to plot Figure 2 in the paper.

```{r}
#| label: env_diff_summs
#| echo: true
#| message: false
#| error: false
#| eval: false

system.time({
cfs <- list()
for(i in 1:length(ys)){
# remove NAs
yi <- names(ys)[i]
# load model object and assemble sdata as above
stanfit_i <- readRDS(paste0(model_fit_dir,"fit_riffle_baci_",names(ys)[i], ".rds"))
drawsi <- as.data.frame(stanfit_i$draws(format = "df", 
                        variables = c("a_s","a_st","gamma", "a_t",
                                      "sigma_s","sigma_t","sigma_st","sigma"))) 
samplesi <- samples[!is.na(samples[,yi]),]
ui <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, data = samplesi)
predx_cf <- expand.grid(intercept = 1, ba = factor(c(0,1,2)), ci = c(0,1), 
                        i = seq(min(ui[,5]),max(ui[,5]),length=10))
predx_cf <- data.frame(model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, 
                                    data = predx_cf))
names(predx_cf) <- names(as.data.frame(ui))
predx_cf$ai <- 10^(predx_cf$i * attr(i_scaled, 'scaled:scale') + 
                     attr(i_scaled, 'scaled:center')) - 0.1
cf_drawsi <- 
      drawsi[,"gamma[1]"] %*% t(predx_cf$`(Intercept)`) +
      drawsi[,"gamma[2]"] %*% t(predx_cf$ba1) +
      drawsi[,"gamma[3]"] %*% t(predx_cf$ba2) +
      drawsi[,"gamma[4]"] %*% t(predx_cf$ci) +
      drawsi[,"gamma[5]"] %*% t(predx_cf$i) + 
      drawsi[,"gamma[6]"] %*% t(predx_cf$`ba1:ci`) +
      drawsi[,"gamma[7]"] %*% t(predx_cf$`ba2:ci`) +
      drawsi[,"gamma[8]"] %*% t(predx_cf$`ba0:ci:i`) + 
      drawsi[,"gamma[9]"] %*% t(predx_cf$`ba1:ci:i`) +
      drawsi[,"gamma[10]"] %*% t(predx_cf$`ba2:ci:i`) 
cfs[[i]] <- cfi <- 
  data.frame(predx_cf, 
             mean = apply(cf_drawsi,2, mean),
             t(as.data.frame(apply(cf_drawsi, 2,
                                    quantile, probs = c(0.025,0.05,0.5,0.95,0.975)))))
names(cfs)[i] <- names(ys)[i]
# the 12 scenarios for calculating differences  
combos <- list(control_hii = which(cfi$ci == 0 & cfi$i == max(cfi$i)),
                 impact_hii = which(cfi$ci == 1 & cfi$i == max(cfi$i)),
                 control_lowi = which(cfi$ci == 0 & cfi$i == min(cfi$i)),
                 impact_lowi = which(cfi$ci == 1 & cfi$i == min(cfi$i)))
env_diffs_i <- baci_diffs(cf_drawsi)
meani = apply(env_diffs_i, 2, FUN = mean)
qlsi <- as.data.frame(t(apply(env_diffs_i, 2, FUN = quantile, 
      probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
meani <- apply(env_diffs_i,2, FUN = mean)
if(i == 1){
  env_diff_summs <- data.frame(stat = names(cfs)[i],
                                  diff = row.names(qlsi), mean = meani, qlsi)
}else{
  env_diff_summs <- rbind(env_diff_summs,
                          data.frame(stat = names(cfs)[i],
                                     diff = row.names(qlsi), mean = meani, qlsi))
}
}
write.csv(env_diff_summs, "small_data/env_diff_summs.csv", row.names = FALSE)
WriteXLS::WriteXLS(cfs, "small_data/env_var_predy_cf.xlsx")
}) # 6 s
```


### The multi-taxon model

The Before-After-Control-Impact effects on count per sample unit of the 113 macroinvertebrate taxa were modelled as a multi-taxon model, assuming a negative binomial distribution of counts, and binomially distributed subsampling error. The Stan code for the model, `nbinom_me_rand_sa_si_t_fixedmatrix-baci.stan`, is reproduced below, with annotations defining variables and parameters, and explaining model components. Below that is the code used to load the data, run, check and evaluate the model, and produce output objects used to produce figures in the manuscript. The multi-taxon model took 2 h to run on a 2.6-GHz system on 4 parallel cores, and compilation of the parameter draws required ~20 Gb RAM.

#### Stan code

```{stan output.var = "mt_mod"} 
#| echo: true
#| eval: false

data {
  int<lower=0> n_obs;         // Number of observations (sample-units, s-u)
  int<lower=1> n_taxa;        // Number of taxa
  int<lower=1> n_site;        // Number of sites
  int<lower=1> n_sample;      // Number of samples (combinations of t_no, site_no)
  int<lower=1> n_pred;        // Number of predictor variables
  int<lower=1> n_t;           // Number of sampling occasions
  matrix[n_obs,n_pred] u;     // group predictors (model matrix) 
  array[n_obs,n_taxa] int c;  // Count of each taxon in each subsample
  array[n_obs,n_taxa] real s; // Subsample proportion for each s-u
  array[n_obs] int site_no;   // Site number
  array[n_obs] int samp_no;   // Sample number (vectorised [t_no, site_no])
  array[n_obs] int t_no;      // Sampling occasion number
}
parameters {
  vector[n_pred] mu_gamma;         //means of beta parameter hyperdistributions          
  matrix[n_pred,n_taxa] gamma;        // beta parameters of fixed effects in u
  matrix[n_site,n_taxa] a_s_raw;      // raw coefficient of random site effect
  matrix[n_t,n_taxa] a_t_raw;         // raw oefficient of time effect 
  matrix[n_sample,n_taxa] a_st_raw;   // raw coefficient of random sample effect 
                                      //(1 sample per site_no per t_no)
  // see reparameterizations below for explanation of these raw coefficients
  vector<lower=0>[n_taxa] sigma_s; //rsd of hyperdistribution of a_ss among taxa
  vector<lower=0>[n_taxa] sigma_t; //sd of hyperdistribution of a_ts among taxa
  vector<lower=0>[n_taxa] sigma_st;//sd of hyperdistribution of a_sts among taxa
  vector<lower=0>[n_taxa] phi;     //dispersion parameter for neg-binomial distn
  corr_matrix[n_pred] Omega;       // Hyperprior correlation matrix among taxa
  vector<lower=0>[n_pred] tau;     // Scale for correlation matrix
}
transformed parameters {
  matrix[n_obs,n_taxa] log_lambda;  // Log total count
  matrix[n_site,n_taxa] a_s;        // coefficient of random site effect
  matrix[n_t,n_taxa] a_t;           // Coefficient of random time effect 
  matrix[n_sample,n_taxa] a_st;     // coefficient of random sample effect
                         // (sample = 3-4 s-us from each site on each occasion)
  for(j in 1:n_taxa){
  a_s[,j] =  sigma_s[j] * a_s_raw[,j];  
  a_t[,j] =  sigma_t[j] * a_t_raw[,j];  
  a_st[,j] =  sigma_st[j] * a_st_raw[,j];  
  }
// with (e.g.) a_s_raw ~ std_normal(), this implies a_s ~ normal(0, sigma_s)
// See https://mc-stan.org/docs/stan-users-guide/reparameterization.html

  for(i in 1:n_obs){
     for(j in 1:n_taxa){
       //The linear model
      log_lambda[i,j] = a_s[site_no[i],j] +  a_t[t_no[i],j] +  
                       a_st[samp_no[i],j] +  u[i,] * gamma[,j]; 
      }
      }
}

model {
  // Priors
   mu_gamma ~ normal(0,5);
   to_vector(a_s_raw) ~ std_normal();
   to_vector(a_t_raw) ~ std_normal();
   to_vector(a_st_raw) ~ std_normal();
   sigma_s ~ normal(0,1);
   sigma_t ~ normal(0,1);
   sigma_st ~ normal(0,1);
   phi ~ normal(1,1);
   tau ~ exponential(1);
   Omega ~ lkj_corr( 2 );  
   
   // estimation of correlated beta parameters (assembled in matrix gamma)
   for(i in 1:n_taxa){
   target += multi_normal_prec_lpdf(gamma[,i] | mu_gamma, quad_form_diag(Omega, 
                                                                         tau) );
     }
  // Likelihood
  for (i in 1 : n_obs) {
    for(j in 1:n_taxa){
    target += neg_binomial_2_log_lpmf(c[i,j] | log_lambda[i,j] + log(s[i,j]), 
                                      phi[j]);
  // This parameterization adds the marginal log-binomial-probability 
  // resulting from subsampling error to the marginal negative-binomial 
  // probability of the linear model.  It is equivalent to a (50 times) slower 
  // parameterization modelling the marginal binomial and negative-binomial
  // probabilities separately, by looping through all feasible total counts
  // given each count and subsample proportion.
   }
  }
}

generated quantities {
  // log-likelihood only used for model comparisons during model development.
  // The most complex model considered has been used,
  // so model comparisons not reported
  array[n_obs,n_taxa] real log_lik;
 for (i in 1 : n_obs) {
   for(j in 1 : n_taxa){
   log_lik[i,j] = neg_binomial_2_log_lpmf(c[i,j] | log_lambda[i,j] +
                    log(s[i,j]), phi[j]);
 }
 }
 }
 
```

#### Assembling data and model sampling: R code

The following code assembles the biotic data for the multi-taxon model, creating a list `mt_data`.

```{r}
#| label: assemble_biotic_data
#| echo: true
#| message: false
#| error: false

# biota, samples etc compiled above in chunk assemble_data
biota <- biota[biota$smpcode %in% samples$smpcode,]
# Convert long-form biota table into a wide taxon-by-sample table of counts 
# in subsamples
biota_ct <- as.data.frame(ct(biota$smpcode, biota$shortcode, biota$count))
biota_ct <- biota_ct[match(samples$smpcode,row.names(biota_ct)),]
# Create a table of the same dimensions as biota_ct, with the subsample proportion
# for each observation (for coarsepick specimens, subsample ppn = 1)
ss_ct <- biota_ct
for(i in 1:nrow(samples)){
  ss_ct[i,] <- samples$subsample_perc[i]/100
}
for(i in which(biota$coarsepick == 1)){
  ss_ct[row.names(ss_ct) == biota$smpcode[i], biota$shortcode[i]] <- 1
}

# data list for Stan: multi-taxon model
mt_data <- list(n_obs = nrow(biota_ct),
              n_taxa = ncol(biota_ct),
              n_site = nrow(sites),
              n_sample = nrow(sample_nos),
              n_pred = ncol(u),
              n_t = max(samples$t),
              site_no = samples$site_no,
              samp_no = samples$sample_no,
              t_no = samples$t_no,
              u = u,
              c = as.matrix(biota_ct),
              s = as.matrix(ss_ct)
)

# data list environmental variable models is compiled iteratively in  chunk 
# sample_env_models
```

The following samples the model, checks sampling diagnostics of sample, and saves the model object and `cmdstanr` csv files holding the posterior draws. It extracts the posterior distributions of the model parameters, saving them as an rdata object, `fit_riffle_baci_draws.rda`.

```{r}
#| label: sample_mt_model
#| echo: true
#| message: false
#| error: false
#| eval: false

# Check model is up-to-date: if not, compile.
mod <- cmdstan_model("nbinom_me_rand_sa_si_t_fixedmatrix_baci.stan", pedantic = TRUE) 
stanfit_i <- mod$sample(data = mt_data,
                        seed = rand_seed, chains = 4,
                        parallel_chains = 4, iter_warmup = 1000,
                        iter_sampling = 4000, refresh = 100)
# 5000 iterations took ~2 h
# #  save csv files rather than the model object to use less RAM
stanfit_i$save_output_files(dir = model_fit_dir, basename = "fit_riffle_baci_mt", 
                            timestamp = FALSE, random = FALSE)
stanfit_i$sampler_diagnostics()
saveRDS(stanfit_i, file = paste0(model_fit_dir,"fit_riffle_baci_mt.rds"))
stanfit_i$diagnostic_summary()
# EBFMI 0.41, 0.53, 0.49, 0.48 zero divergences, zero max tree depth reached.
# # The above three steps required < 500 Mb RAM
summ <- stanfit_i$summary() # took an additional 0.5 h and needed >40 Gb RAM
min(summ$ess_bulk,na.rm=TRUE) # 569
min(summ$ess_tail,na.rm=TRUE) # 943
max(summ$rhat,na.rm=TRUE)  # 1.013
# # all diagnostic_summary diagnostics were satisfied

mod_draws <- as.data.frame(stanfit_i$draws(format = "df", variables = c("a_s","a_t","a_st","gamma","phi")))
save(mod_draws, file = paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
```

The following uses the posterior distributions of the model parameters to predict mean abundance for each taxon in each sample (for assessment of model fit), using the unique predictor combinations of all samples in the dataset (`predx`, described above)  The resulting object `predy_draws` is a list of 113 elements (one for each taxon; the name of each element = the relevant taxoncode).  Each element is a data.frame with 53 columns (matching predx rows) and 16000 rows (4000 samples times 4 chains): the posterior distribution of the predicted mean abundance of each taxon for each `predx` value. 
`param_summs` is a list of summary tables of quantiles of each distribution for each taxon, saved as `param_summs.xlsx`, with 113 sheets containing the table for each taxon.

```{r}
#| label: predy_summary
#| echo: true
#| eval: false

# load draws of parameters from model if necessary (object mod_draws calculated above)
# load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
predx <- unique(cbind(samples[c("sample","site_no","sample_no","t_no")],u))

predy_draws <- list()
system.time({
for(i in 1:mt_data$n_taxa){
  drawsi <- mod_draws[grep(paste0(",",i,"]"), names(mod_draws))]
  predy_draws[[i]] <-
    drawsi[substr(names(drawsi),1,3) == "a_s"][match(predx$site_no, 1:mt_data$n_site)] +
    drawsi[substr(names(drawsi),1,3) == "a_t"][match(predx$t, 1:mt_data$n_t)] +
    drawsi[substr(names(drawsi),1,4) == "a_st"][match(predx$sample_no, 1:mt_data$n_sample)] +
      drawsi[,paste0("gamma[1,",i,"]")] %*% t(predx$`(Intercept)`) +
       drawsi[,paste0("gamma[2,",i,"]")] %*% t(predx$ba1) +
       drawsi[,paste0("gamma[3,",i,"]")] %*% t(predx$ba2) +
       drawsi[,paste0("gamma[4,",i,"]")] %*% t(predx$ci) +
       drawsi[,paste0("gamma[5,",i,"]")] %*% t(predx$i) + 
       drawsi[,paste0("gamma[6,",i,"]")] %*% t(predx$spring) +
       drawsi[,paste0("gamma[7,",i,"]")] %*% t(predx$`ba1:ci`) +
       drawsi[,paste0("gamma[8,",i,"]")] %*% t(predx$`ba2:ci`) +
       drawsi[,paste0("gamma[9,",i,"]")] %*% t(predx$`ba0:ci:i`) + 
       drawsi[,paste0("gamma[10,",i,"]")] %*% t(predx$`ba1:ci:i`) +
       drawsi[,paste0("gamma[11,",i,"]")] %*% t(predx$`ba2:ci:i`) 
}
})  # 1 min
names(predy_draws) <- colnames(mt_data$c)
save(predy_draws, file = paste0(model_fit_dir,"fit_riffle_baci_predy_draws.rda"))

params <- c("b_ba1", "b_ba2", "b_ci","b_i","b_spring","b_ba1ci","b_ba2ci","b_ba0cii","b_ba1cii", "b_ba2cii")
df_empty <- data.frame(shortcode = NA, mean = NA, lo95 = NA, lo90 = NA, median = NA, hi90 = NA, hi95 = NA)[0,]
mod_draws <- get(load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda")))
param_summs <- list()
for(i in 1:length(params)){
  drawsi <- mod_draws[substr(names(mod_draws),1,ifelse(i < 9, 7, 8)) == paste0("gamma[", i + 1) & 
                          grepl("gamma", names(mod_draws))]
  qlsi <- as.data.frame(t(apply(drawsi,2, FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- apply(drawsi,2, FUN = mean)
  param_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(param_summs) <- params
WriteXLS::WriteXLS(param_summs, "small_data/param_summs.xlsx")
```

The following extracts the posterior distribution of mean abundance for each taxon in samples across the gradient of imperviousness for all combinations of *ba* = 0, 1 or 2; *ci* = 0 or 1; *I* = minimum and maximum values in dataset (=4% and 32% EI); spring = 0 (i.e. autumn), omitting random sample, site and t errors, and the primary differences of interest in the BACI design, as described above.  

```{r}
#| label: pred_cf
#| echo: true
#| eval: false

# load draws of parameters from model if necessary (object mod_draws calculated above)
#load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))

# predx_cf is the table of scenario predictor variables for counterfactual plots/analysis
# predy_cf is a list with 113 elements, one for each taxon (each element has a taxoncode as a name)
# each element is a table of posterior distributions (32000 draws in rows) for the 60 scenarios (in columns)
predx_cf <- expand.grid(intercept = 1, ba = factor(c(0,1,2)), ci = c(0,1), 
                        i = seq(min(u[,5]),max(u[,5]),length=10), spring = 0)
predx_cf <- data.frame(model.matrix(~ ba + ci + ba:ci + i + ba:ci:i + spring, 
                                    data = predx_cf))
predx_cf$ai <- 10^(predx_cf$i * attr(i_scaled, 'scaled:scale') + 
                attr(i_scaled, 'scaled:center')) - 0.1
predy_cf <- delta_baci1_low <- delta_baci2_low <- delta_baci1_hi <- delta_baci2_hi <- list()

# delta_posts takes 12 of the scenarios and calculates four differences used as evidence of riffle effect.
# it is a list of four lists (one for each difference). Each difference has 113 elements (taxa, as above)
# and each element is a vector length 32000 of the posterior distribution of the diffence for each taxon.
  
# As for the environmental variables, the 12 scenarios for calculating differences  
combos <- list(control_hii = which(predx_cf$ci == 0 & predx_cf$i == max(predx_cf$i)),
               impact_hii = which(predx_cf$ci == 1 & predx_cf$i == max(predx_cf$i)),
               control_lowi = which(predx_cf$ci == 0 & predx_cf$i == min(predx_cf$i)),
               impact_lowi = which(predx_cf$ci == 1 & predx_cf$i == min(predx_cf$i)))

system.time({
for(i in 1:mt_data$n_taxa){
  drawsi <- mod_draws[grep(paste0(",",i,"]"), names(mod_draws))]
  predy_cf[[i]] <-
       drawsi[,paste0("gamma[1,",i,"]")] %*% t(predx_cf$X.Intercept.) +
       drawsi[,paste0("gamma[2,",i,"]")] %*% t(predx_cf$ba1) +
       drawsi[,paste0("gamma[3,",i,"]")] %*% t(predx_cf$ba2) +
       drawsi[,paste0("gamma[4,",i,"]")] %*% t(predx_cf$ci) +
       drawsi[,paste0("gamma[5,",i,"]")] %*% t(predx_cf$i) + 
       drawsi[,paste0("gamma[6,",i,"]")] %*% t(predx_cf$spring) +
       drawsi[,paste0("gamma[7,",i,"]")] %*% t(predx_cf$ba1.ci) +
       drawsi[,paste0("gamma[8,",i,"]")] %*% t(predx_cf$ba2.ci) +
       drawsi[,paste0("gamma[9,",i,"]")] %*% t(predx_cf$ba0.ci.i) + 
       drawsi[,paste0("gamma[10,",i,"]")] %*% t(predx_cf$ba1.ci.i) +
       drawsi[,paste0("gamma[11,",i,"]")] %*% t(predx_cf$ba2.ci.i) 
}
names(predy_cf) <- names(biota_ct)
 
for(i in 1:mt_data$n_taxa){
delta_baci1_low[[i]] <- predy_cf[[i]][,combos$control_lowi[1]] - predy_cf[[i]][,combos$impact_lowi[1]] -
                    (predy_cf[[i]][,combos$control_lowi[2]] - predy_cf[[i]][,combos$impact_lowi[2]])
delta_baci2_low[[i]] <- predy_cf[[i]][,combos$control_lowi[1]] - predy_cf[[i]][,combos$impact_lowi[1]] -
                    (predy_cf[[i]][,combos$control_lowi[3]] - predy_cf[[i]][,combos$impact_lowi[3]])
delta_baci1_hi[[i]] <- predy_cf[[i]][,combos$control_hii[1]] - predy_cf[[i]][,combos$impact_hii[1]] -
                    (predy_cf[[i]][,combos$control_hii[2]] - predy_cf[[i]][,combos$impact_hii[2]])
delta_baci2_hi[[i]] <- predy_cf[[i]][,combos$control_hii[1]] - predy_cf[[i]][,combos$impact_hii[1]] -
                    (predy_cf[[i]][,combos$control_hii[3]] - predy_cf[[i]][,combos$impact_hii[3]])
}
})  # 5 s

# summary table of precentiles for all species for 12 scenarios used for 
# inference of baci effect
taxon_abun_cf_summs <- list()
for(i in unlist(combos)){
  list_index <- which(unlist(combos) == i)
  tabi <- data.frame(taxoncode = names(predy_cf), 
                     mean = NA, "lo95" = NA, "lo90"= NA, "lo75" = NA,
                    "median" = NA,"hi75" = NA,"hi90" = NA,"hi95" = NA)
  for(j in 1:length(predy_cf)){
    tabi$mean[j] <- mean(predy_cf[[j]][,i])
    tabi[j,-(1:2)] <- quantile(predy_cf[[j]][,i], 
                             probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))
  }
  taxon_abun_cf_summs[[list_index]] <- tabi
}
names(taxon_abun_cf_summs) <- names(unlist(combos))
WriteXLS::WriteXLS(taxon_abun_cf_summs, "small_data/taxon_abun_cf_summs.xlsx")

delta_posts <- list(delta_a1_4ei = delta_baci1_low, 
                    delta_a2_4ei = delta_baci2_low, 
                    delta_a1_32ei = delta_baci1_hi, 
                    delta_a2_32ei = delta_baci2_hi)
save(predy_cf, delta_posts, 
     file = paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

diff_summs <- list()
for(i in 1:length(delta_posts)){
  qlsi <- as.data.frame(do.call(rbind,lapply(delta_posts[[i]],FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- unlist(lapply(delta_posts[[i]],FUN = mean))
  diff_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(diff_summs) <- names(delta_posts)
WriteXLS::WriteXLS(diff_summs, "small_data/diff_summs.xlsx")
```

```{r}
#| label: calc_assemb_stats
#| echo: false
#| eval: false

# load draws of parameters from model (from above) if necessary
# load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
# load taxon abundance predictions for 60 counter-factual scenarios (from above) if necessary
load(paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

phi_draws <- mod_draws[,grep("phi",names(mod_draws))]
p_cf_mat <- list()
n_cf_mat <- list()

# And use them to calculate assemblage statistics

# system.time({
for(t in 1:ncol(biota_ct)){
p_cf_mat[[t]] <- predy_cf[[t]]
n_cf_mat[[t]] <- exp(predy_cf[[t]])
for(i in 1:ncol(p_cf_mat[[t]]))
  # Probability of occurrence in 1 sample unit
p_cf_mat[[t]][,i] <- 1 - pnbinom(0,mu = exp(predy_cf[[t]][,i]),
                                 size = phi_draws[t][,1])
  # Probability of occurrence in 4 sample units
p_cf_mat[[t]] <- 1 - (1 - p_cf_mat[[t]])^4
  # back-transformed abundance per 4 samples
}
# }) # ~15 s
names(p_cf_mat) <- colnames(biota_ct)
tot_rich_cf_mat <- Reduce('+', p_cf_mat)
# see https://stackoverflow.com/questions/11641701/sum-a-list-of-matrices
ept_rich_cf_mat <- Reduce('+', p_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QE","QP","QT")])
do_rich_cf_mat <- Reduce('+', p_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QD","LO")])

tot_n_cf_mat <- Reduce('+', n_cf_mat)
ept_n_cf_mat <- Reduce('+', n_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QE","QP","QT")])
do_n_cf_mat <- Reduce('+', n_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QD","LO")])

library(vegan)

# Shannon's H' requires proportional abundances
relab_cf_mat <- n_cf_mat
tot_abund_cf_mat <- Reduce('+', n_cf_mat)
for(i in 1:length(n_cf_mat)){
relab_cf_mat[[i]] <- relab_cf_mat[[i]] / tot_abund_cf_mat
}

H_mat <- relab_cf_mat[[1]]
for(i in 1:nrow(H_mat)){
H_mat[i,] <- diversity(sapply(relab_cf_mat,function(x, n) x[n,],i))
}

# Pielou's Evenness
evenness_cf_mat <- H_mat/log(tot_rich_cf_mat)

# Reduce set to family-presence absence for SIGNAL calculation
biotic_indices<- 
  read.csv("small_data/biotic_indices.csv")
signal <- biotic_indices[!is.na(biotic_indices$SIGNALWoV2003),
                         c("shortcode","taxon","SIGNALWoV2003")]
signal <- signal[signal$shortcode %in%
                             c("LO",substr(names(biota_ct),1,4)),]
signal <- signal[order(signal$shortcode),]
signal_mat <- list()
for(i in 1:nrow(signal)){
  ss <- ifelse(signal$shortcode[i] == "LO",
               which(substr(names(p_cf_mat),1,2) == "LO"),
               which(substr(names(p_cf_mat),1,4) %in% signal$shortcode[i]))
  signal_mat[[i]] <-
    Reduce(function(x) 1-(1-x)^length(ss), p_cf_mat[ss])
  signal_mat[[i]] <- matrix(unlist(Map(function(x) rbinom(1,1,x),
                            signal_mat[[i]])),ncol = ncol(p_cf_mat[[1]]))
  signal_mat[[i]][signal_mat[[i]] > 0] <-
    signal_mat[[i]][signal_mat[[i]] > 0]* signal$SIGNALWoV2003[i]
}
signal_sum_cf_mat <- Reduce('+', signal_mat)
signal_len_cf_mat <- Reduce('+', lapply(signal_mat, function(x)
                      replace(x, x > 0, 1)))
signal_cf_mat <- signal_sum_cf_mat/signal_len_cf_mat

baci_diffs <- function(mat){
  data.frame(delta_baci1_low = 
               mat[,combos$control_lowi[1]] - mat[,combos$impact_lowi[1]] -
                    (mat[,combos$control_lowi[2]] - mat[,combos$impact_lowi[2]]),
             delta_baci2_low = 
               mat[,combos$control_lowi[1]] - mat[,combos$impact_lowi[1]] -
                    (mat[,combos$control_lowi[3]] - mat[,combos$impact_lowi[3]]),
             delta_baci1_hi =
               mat[,combos$control_hii[1]] - mat[,combos$impact_hii[1]] -
                    (mat[,combos$control_hii[2]] - mat[,combos$impact_hii[2]]),
             delta_baci2_hi = mat[,combos$control_hii[1]] - mat[,combos$impact_hii[1]] -
                    (mat[,combos$control_hii[3]] - mat[,combos$impact_hii[3]]))
}

assemb_stats <- list(tot_rich = 
                       data.frame(mean =apply(tot_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(tot_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     shannon_h = 
                       data.frame(mean =apply(H_mat,2, 
                                              FUN = mean),
                                  t(apply(H_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     evenness = 
                       data.frame(mean =apply(evenness_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(evenness_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     ept_rich = 
                       data.frame(mean =apply(ept_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(ept_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     do_rich = 
                       data.frame(mean = apply(do_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(do_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     signal = 
                       data.frame(mean =apply(signal_cf_mat,2, 
                                              FUN = mean, na.rm = TRUE),
                                  t(apply(signal_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975), 
                                          na.rm = TRUE))),
                     tot_n = 
                       data.frame(mean =apply(tot_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(tot_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     ept_n = 
                       data.frame(mean =apply(ept_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(ept_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     do_n = 
                       data.frame(mean =apply(do_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(do_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975))))
                     )
WriteXLS::WriteXLS(assemb_stats, "small_data/assemb_stat_summs.xlsx")

assemb_stat_diffs <- list(signal = baci_diffs(signal_cf_mat),
                          evenness = baci_diffs(evenness_cf_mat),
                          H = baci_diffs(H_mat),
                          tot_rich = baci_diffs(tot_rich_cf_mat),
                          ept_rich = baci_diffs(ept_rich_cf_mat),
                          do_rich = baci_diffs(do_rich_cf_mat),
                          tot_n = baci_diffs(tot_n_cf_mat),
                          ept_n = baci_diffs(ept_n_cf_mat),
                          do_n = baci_diffs(do_n_cf_mat))
save(assemb_stat_diffs, file =paste0(model_fit_dir,"assemb_stat_diffs.rda"))

assemb_stat_diffs <-  assemb_stat_diffs[match(c("tot_rich","ept_rich","do_rich",
                                                "signal","tot_n","ept_n","do_n","H","evenness"),
                                              names(assemb_stat_diffs))]
for(i in 1:length(assemb_stat_diffs)){
  drawsi <- assemb_stat_diffs[[i]]
  qlsi <- as.data.frame(t(apply(drawsi,2, FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- apply(drawsi,2, FUN = mean)
  if(i == 1){
  assemb_stat_diff_summs <- data.frame(stat = names(assemb_stat_diffs)[i],
                                       diff = row.names(qlsi), mean = meani, qlsi)
             }else{
  assemb_stat_diff_summs <- rbind(assemb_stat_diff_summs,
                                   data.frame(stat = names(assemb_stat_diffs)[i],
                                               diff = row.names(qlsi), 
                                              mean = meani, qlsi))
                    }
}
WriteXLS::WriteXLS(assemb_stat_diff_summs, "small_data/assemb_stat_diff_summs.xlsx")

# Extract mean abundances in the 12 main scenarios for the top 10 taxa in each scenario
# (For table 1 in the manuscript)
relabunds <- data.frame(scenario = names(unlist(combos)),
                        matrix(nrow = length(unlist(combos)),
                               ncol = length(relab_cf_mat)))
names(relabunds)[-1] <- colnames(mt_data$c)
for(i in 1:length(relab_cf_mat)){
  relabunds[,i + 1] <- apply(relab_cf_mat[[i]][,unlist(combos)],2,FUN = mean)
}
top10_propns <- data.frame(scenario = relabunds$scenario, propn = NA)
top10s <- list()
for(i in 1:nrow(relabunds)){
  rai <- t(relabunds[i,-1])
  top10s[[i]] <- row.names(rai)[order(rai, decreasing =  TRUE)[1:10]]
  top10_propns[i,2] <- sum(rai[order(rai, decreasing =  TRUE)[1:10]])
}
tops <- data.frame(taxoncode = c(unique(unlist(top10s[])),NA),
                   Taxon = c(taxa$taxon[match(unique(unlist(top10s[])), 
                                                       taxa$taxoncode)],"% of all taxa"),
                   High.I_Control_B = NA, High.I_Control_A1 = NA, High.I_Control_A2 = NA, 
                   High.I_Impact_B = NA, High.I_Impact_A1 = NA, High.I_Impact_A2 = NA, 
                   Low.I_Control_B = NA, Low.I_Control_A1 = NA, Low.I_Control_A2 = NA, 
                   Low.I_Impact_B = NA, Low.I_Impact_A1 = NA, Low.I_Impact_A2 = NA)
for(i in 1:(nrow(tops)-1)){
  tops[i,-(1:2)] <- round(apply(n_cf_mat[[which(colnames(mt_data$c) == tops$taxoncode[i])]][,unlist(combos)],
                          2,FUN = mean))
}
tops[nrow(tops),-(1:2)] <- round(top10_propns$propn*100)
write.csv(tops,"small_data/top10taxa.csv",row.names = FALSE)
```

## 2. Assessment of model fit

We assessed the predictive performance of our model by comparing model predictions of abundance to observed abundance at each site including the random site, stream and time effects.

### Methods

We quantified model accuracy and bias first by calculating the correlation coefficient, *R*, and slope of the linear regression between predicted and observed values of each model.  The environmental variables were transformed as they were in the model, and for the multi-taxon model, we used log-mean abundance \[log(x + 1)\] of each taxon in each sample (count in each sample unit estimated as count/subsample fraction). We assessed prediction at the level of sample rather than at the sample-unit level because the model allows prediction at that level, and our primary interest is to predict mean response to riffle construction at the site level.

We also assessed accuracy of model predictions for occurrence of each taxon (rather than abundance) by assessing the area under the operator curve (AUC) for logistic regressions between predicted probability of occurrence and observed presence or absence in each sample, where predicted probability of occurrence in a sample,

$$
p\_s = 1 - \Pi(1 - p\_{su}_i)
$$ {#eq-s3_ps}

where $p\_su_i$ is the probability of occurrence in the *i*th sample unit comprising the sample, calculated as 1 - negative-binomial probabliity of zero, given predicted $\mu$ and $\phi$.

Finally, we assessed the accuracy of the multi-taxon model's estimates of assemblage level metrics, by calculating the *R^2^* and slope of the linear regression between predicted and observed number of taxa in each sample, both total number of taxa, and the number of Ephemeropotera, Plecoptera and Trichoptera taxa (three groups of sensitive species commonly used as a stream health metric). Predicted number of taxa was estimated as the sum of probabilities of occurrence for all taxa. Because observed taxon richness is likely to be affected by subsample size, we interpreted the relationship between predicted and observed numbers of taxa accounting for mean subsample proportion in the subsample units making up each sample. We also calculated *R^2^* of the predicted number of taxa as a function of observed number of taxa + mean subsample proportion.

### Results

All environmental variables were well predicted by their respective models, with almost perfect correlation between observed and predicted (Table 1).

The abundances of all taxa (estimated as the number counted divided by the subsample fraction) were well predicted by the model. The observed and predicted abundances of all taxa were correlated with R \> 0.75 (@fig-nbinom_me_fit_by_taxon A). Abundance predictions of 42 prevalent and abundant taxa, including all but one of those for which an effect of the experimental riffles was inferred, showed little bias (regression slopes between 0.8 and 1.1), while abundance predictions for taxa with low prevalence tended to be underestimated (slopes \< 0.8, @fig-nbinom_me_fit_by_taxon B). Such underestimation is to be expected for taxa with many zero or low abundances.

The model also predicted occurrence of all taxa with high certainty (all AUC values of the 111 taxa absent from at least one sample \> 0.85, @fig-nbinom_pa_stats). The probabilities of occurrence of all taxa summed to accurate estimates of taxon richness in the 56 samples (@fig-richness_op). The raw correlation between predicted and observed numbers of all taxa was reduced by the effect of subsampling (@fig-richness_op A). The predicted number of taxa was higher than the observed for samples with lower numbers of taxa because more of them had small subsample fractions compared to more taxa-rich samples. The regression of predicted \~ observed + subsample fraction had a higher *R^2^* (0.64). The model predicted EPT richness with high accuracy (*R^2^* 0.88), with a small negative effect of subsample fraction (@fig-richness_op B).

The accurate prediction of the data by all models provide confidence in inferences of the experimental effects of interest.

```{r}
#| label: fig-nbinom_me_fit_by_taxon
#| echo: false
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 3.5
#| fig-cap: "a) Correlation coefficients for each taxon of between observed (count in each subsample divided by subsample fraction, log(x + 1)-transformed and averaged for all sample units in each sample) and predicted (P) abundances (mean estimate of log-mean abundances of each taxon in the sample from each site), and b) Slopes of the regression of predicted as a function of observed, both plotted against prevalence of each taxon. Green points indicate taxa for which a non-zero effect of riffle construction was inferred at the 90% confidence level."

# load object predy_draws, calculated above 
predy_draws <- get(load(paste0(model_fit_dir,"fit_riffle_baci_predy_draws.rda")))

# Calculate Observed (mean log-transformed counts per sample) to Expected (predicted mean abundance per sample)
oe_stats <- data.frame(taxoncode = colnames(mt_data$c), 
                       cor = NA, slope = NA, adj_r_squ = NA)
for(i in 1:mt_data$n_taxa){
  y <- log(exp(apply(predy_draws[[colnames(mt_data$c)[i]]],2,FUN = mean)) + 1)
  x <- aggregate(log(mt_data$c[,i]/mt_data$s[,i] + 1),
                       by = list(site_no = samples$site_no, 
                       sample_no = samples$sample_no,
                       t = samples$t), FUN = mean)$x
  oe_stats$cor[i] <- cor(x,y)
  lmi <- lm(y ~ x)
  oe_stats$adj_r_squ[i] <- summary(lmi)$adj.r.squared
  oe_stats$slope[i] <- coefficients(lmi)[2]
  }

# Calculate prevalence of each taxon by sample
prevalence <- apply(biota_ct, 2, FUN = function(x){sum(x > 0)})
prevalence_by_sample <- data.frame(shortcode = colnames(biota_ct), prev = NA)
for(i in 1:ncol(biota_ct)){
  prevalence_by_sample$prev[i] <- 
    sum(aggregate(biota_ct[,i], by = list(sample_no = samples$sample_no), 
            FUN = function(x) as.numeric(sum(x) > 0))$x)
}

# Find those taxa for which a riffle effect is inferred in the paper and highlight on plot
# (vectors of taxacodes, more_diff_90 and more_sim_90, also used in main paper)
# load objects: (a list predy_cf; and ) a list of lists delta_post, containing lists
# delta_baci1_low, delta_baci2_low, delta_baci1_hi, delta_baci1_hi - see S3 chunk pred_cf
load(paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

diff_summs <- list()
for(i in 1:length(delta_posts)){
  qlsi <- as.data.frame(do.call(rbind,lapply(delta_posts[[i]],FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- unlist(lapply(delta_posts[[i]],FUN = mean))
  diff_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(diff_summs) <- names(delta_posts)
more_diff_90 <- more_diff_95 <- more_sim_90 <- more_sim_95 <- vector()
for(i in 1:length(delta_posts)){
more_diff_90 <- unique(c(more_diff_90,diff_summs[[i]]$shortcode[diff_summs[[i]]$lo90 > 0]))
more_sim_90 <- unique(c(more_sim_90,diff_summs[[i]]$shortcode[diff_summs[[i]]$hi90 < 0]))
}

bgs <- rep(NA, mt_data$n_taxa)
bgs[names(biota_ct) %in% unique(c(more_diff_90,more_sim_90))] <- "green"
cols <- bgs; cols[is.na(cols)] <- "black"
layout(matrix(c(1,2,3,3),2,2,byrow=TRUE), widths = c(12,12), heights = c(12,1))
par(mar = c(2,4,1,1))
xpos <- jitter(prevalence_by_sample$prev)
plot(xpos, oe_stats$cor,
     xlim = c(0,53), ylim = c(0,1), pch = 21, bg = bgs,
     axes = FALSE, ylab = "R (O:P)", xlab = "")
abline(h = 1, lty = 3)
axis(1); axis(2, las = 1); box(bty = "l")
title("A.", adj = 0)
plot(xpos, oe_stats$slope,
     ylim = c(0,1.25),pch = 21, bg = bgs,
     axes = FALSE, ylab = "Regression slope (O ~ P)", xlab = "")
abline(h = 1, lty = 3)
axis(1); axis(2, las = 1); box(bty = "l")
title("B.", adj = 0)
par(mar = c(0,0,0,0))
plot.new()
title(xlab = "Prevalence (number of samples with abundance > 0)", line = -1.5)

write.csv(oe_stats, "small_data/riffle_baci_oe_stats.csv", row.names = FALSE)
```

```{r}
#| label: fig-nbinom_pa_stats
#| echo: false
#| warning: false
#| message: false
#| fig-width: 4
#| fig-height: 4
#| fig-cap: "a) Area under the receiver operator characteristic curve (AUC) of predictions of presence-absence from the negative-binomial model for 111 taxa as a function of their prevalence in the 53 samples. AUC could not be calculated for the two taxa that occurred in all samples (Nematoda and Enchytraiedae)."

# load draws of parameters from model (object mod_draws calculated above)
load(paste0(model_fit_dir, "fit_riffle_baci_draws.rda"))

phi_draws <- mod_draws[,grep("phi",names(mod_draws))]
p_mat <- list()
# system.time({
for(t in 1:mt_data$n_taxa){
p_mat[[t]] <- predy_draws[[colnames(biota_ct)[t]]]
for(i in 1:ncol(p_mat[[t]]))
p_mat[[t]][,i] <- 1 - pnbinom(0,mu = exp(predy_draws[[colnames(biota_ct)[t]]][,i]),size = phi_draws[t][,1])
}
# }) # ~15 s
names(p_mat) <- colnames(biota_ct)
p_mean <- matrix(nrow = mt_data$n_sample, ncol= mt_data$n_taxa)
for(t in 1:mt_data$n_taxa){
  p_mean[,t] <- apply(p_mat[[t]], 2, FUN = mean)
}

# Function for calculating probability of occurrence in n sample units, given a vector of probabilities, x, of length n
p_per_n <- function(x) {1 - prod(1 - x)} # x, a vector of probabilities

p_mean_per_sample <- matrix(ncol = mt_data$n_sample, nrow = mt_data$n_taxa)
for(t in 1:mt_data$n_taxa){
  for(j in 1:mt_data$n_sample){
    p_mean_per_sample[t,j] <- p_per_n(rep(p_mean[j,t],sum(samples$sample_no == j)))
  }}

# Probability of presence in observed data
obs_per_sample <- matrix(ncol = mt_data$n_sample, nrow = mt_data$n_taxa)
for(t in 1:mt_data$n_taxa){
    obs_per_sample[t,] <- aggregate(biota_ct[,t], 
                                     list(sample_no = samples$sample_no), 
                                     FUN = function(y) {sum(y > 0) > 0})$x
  }

library("PresenceAbsence")
pa_stats <- data.frame(shortcode = colnames(biota_ct),
                       taxon = taxa$taxon[match(colnames(biota_ct),taxa$shortcode)], 
                       prevalence = prevalence_by_sample$prev[match(prevalence_by_sample$shortcode, colnames(biota_ct))],
                       PCC = NA,
                       sensitivity = NA, specificity = NA, Kappa = NA, AUC = NA)
for(t in 1:mt_data$n_taxa){
  pa_data <- data.frame(taxon = colnames(biota_ct)[t],
                        obs_per_sample[t,],p_mean_per_sample[t,])
  pa_stats[t,-(1:3)] <- presence.absence.accuracy(pa_data)[c("PCC","sensitivity","specificity","Kappa","AUC")] 
}
par(mar = c(4,4,1,1),mfrow = c(1,1))
plot(pa_stats$prevalence, pa_stats$AUC, ylim = c(0.5,1),xlab = "", ylab = "AUC")
title(xlab = "Prevalence (number of samples with abundance > 0)",)

pa_stats <- pa_stats[,names(pa_stats) != "taxon"]
write.csv(pa_stats, "small_data/riffle_baci_pa_stats.csv", row.names = FALSE)
```

```{r}
#| label: fig-richness_op
#| echo: false
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 4
#| fig-cap: "Predicted mean number of taxa (A. total, B. Ephemeroptera, Plecoptera and Trichoptera, EPT) in the 53 samples plotted against observed richness. The solid line indicates the 1:1 relationship, and the dashed line the linear regression of predicted as a function of observed.  The R-squared values indicate the adjusted R-squared of the linear regression of predicted ~ observed, and the values in brackets are for the regression predicted ~ observed + s, where s is the mean subsample proportion of the sample. Points are sized by s."

par(mfrow = c(1,2))
par(mar = c(4,4,1,1))
sample_p <- vector("numeric",length = mt_data$n_sample)
for(i in 1:mt_data$n_sample){
  sample_p[i] <- mean(0.01* samples$subsample_perc[samples$sample_no == i])
}
x <- apply(obs_per_sample,2, FUN = sum)
y <- apply(p_mean_per_sample,2, FUN = sum)
plot(x, y, cex = sample_p + 0.5, axes = FALSE, 
     xlab = "Observed no. taxa", ylab = "Predicted no. taxa")
axis(1); axis(2, las = 1); box(bty = 'l')
abline(0,1)
abline(lm(y ~ x), lty = 3)
r21 <- round(summary(lm(y ~ x))$adj.r.squared,2)
r22 <- round(summary(lm(y ~ x + sample_p))$adj.r.squared,2)
title(main = "A.", adj = 0)
title(main = paste0("  R-sq = ", r21, " (", r22, ")"), 
      adj = 0, line = -1, font.main = 1, cex.main = 1)

x <- apply(obs_per_sample[substr(names(p_mat),1,2) %in% c("QE","QP","QT"),],2, FUN = sum)
y <- apply(p_mean_per_sample[substr(names(p_mat),1,2) %in% c("QE","QP","QT"),],2, FUN = sum)
plot(x, y, cex = sample_p + 0.5, axes = FALSE, 
     xlab = "Observed no. EPT taxa", ylab = "Predicted no. EPT taxa")
axis(1); axis(2, las = 1); box(bty = 'l')
legend("bottomright", pch = 1, pt.cex = c(0.6,1.0,1.5), 
       legend = c(0.1,0.5,1.0),title = "s")
abline(0,1)
abline(lm(y ~ x), lty = 3)
r21 <- round(summary(lm(y ~ x))$adj.r.squared,2)
r22 <- round(summary(lm(y ~ x + sample_p))$adj.r.squared,2)
title(main = "B.", adj = 0)
title(main = paste0("  R-sq = ", r21, " (", r22, ")"), 
      adj = 0, line = -1, font.main = 1, cex.main = 1)

```

## References