---
title: "Appendix S3 for 'Constructed rock riffles increase habitat heterogeneity but not biodiversity in streams constrained by urban impacts'"
author: "Christopher J Walsh, J Angus Webb, Daniel C Gwinn, and Peter F Breen"
format: docx
editor: visual
bibliography: references.bib
csl: ecological-applications.csl
---

## Methods and code for fitting and assessing the models

```{r}
#| echo: false
#| message: false
#| error: false
#| include: false

######### READ THIS CHUNK BEFORE PROCEEDING ########
# If you want to run the 'eval: false' chunks in this document, you will need to 
# adjust the following directory for keeping large files
model_fit_dir <- 
    "~/uomShare/wergStaff/ChrisW/git-data/urban_riffle_experiment/model_fits/"

## Packages required for evaluated chunks
requiredPackages <- c("osfr","dplyr","flextable","rio")
lapply(requiredPackages, require, character.only = TRUE)
## Packages required for 'eval: false' chunks: WriteXLS and cmdstanr 
## (See chunk 'sample_env_models')

## Check if there is a 'data' directory. If not make one
if(!"data" %in% dir()){dir.create("data")}
## Check for large data files. If absent download them 
# ## from the OSF repository to the data directory
big_files <- c("ia_5m_raster.tif","urban_riffle_exp_survey_data_combined.xlsx",
               "urban_riffle_experiment_data_for_model.xlsx",
               "urban_riffle_experiment_map.gpkg")
missing <- big_files[!big_files %in% dir("data")]
if(length(missing) > 0){
 dl_files <- osf_retrieve_node("cms84") %>% osf_ls_files()
 osf_download(dl_files, path = "data", conflicts = "skip")
 }
```

The first part of this document details the specifications and code used to estimate the statistical models of environmental variables and of taxon abundance. The second part assesses the fit of the models.

## 1. Model specification

The models followed the typical BACI design, expanded to include two 'after' time periods (A1, in the first year after construction; and A2, 5--6 y after construction) and to account for the potential moderating effects of effective imperviousness I(scaled, log(x + 0.1) % catchment EI). The experimental effects were coded as combinations of 5 binary variables: B (= 1 before construction), A1, A2, C (control sites) and R (sites in which riffles were constructed).

We estimated the posterior distributions of parameters in the multi-taxon model of taxon abundances and the models of environmental variables (depth, velocity and $\Phi$, particle size) in the sample units using the Markov chain Monte-Carlo (MCMC) sampler of Stan [@carpenter_etal_2017], calling Stan from R using the library `cmdstanr` [@gabry_cesnovar_2022].

We modeled the environmental variables (transformed as necessary and scaled, Table 1) as normal distributions with standard deviation (sd) having a prior half-normal distribution (mean 0, sd 3): in all cases, the posterior distribution was a small subset of this. In the multi-taxon model, we modeled count of each taxon in each sample unit as a negative binomial distribution with the prior for distribution of the dispersion parameter for taxon *j* ($\phi_j$) set as a random effect drawn from a common assemblage-level normal hyper-distribution as; $1/\sqrt\phi_j \sim \ \textrm{Normal}(\mu_j, \sigma_j)$, where $\mu_j$ and $\sigma_j$ are the assemblage level mean and standard deviation respectively, with prior half-normal distributions (mean 0, sd 5). The inverse square root of $\phi$ was used to avoid concentration of the prior mass on highly over-dispersed distributions [@stan_dev_team_2022].

```{r}
#| label: tbl-env_vars
#| echo: false
#| tbl-cap: "The transformations of the six environmental variables reported in the paper used to model their response to urban riffle construction. Phi is the negative log (base 2) of the smallest diameter (mm) of a sediment particle. R^2^ is of the relationship between predicted mean values and the mean (transformed) observed values of each variable in each sample. 'Prediction fidelity' is the proportion of observed sample mean that fell within 95% of the posterior predicted distribution for each sample."

gofs <- read.csv("small_data/env_gofs.csv")
gofs <- gofs[gofs$model != "max_phi",]
ft <- data.frame(Variable = c("Variance of depth (m)", "Mean of depth (m)", 
                              "Variance of velocity (m/s)", "Mean of Velocity (m/s)",
                              "Minimum Phi", "Median Phi"),
                 Transformation = c("log(x + 0.00175)", "log(x)", 
                                    "log(x + 0.0007442)", "log(x)","None","None"),
                 R2 = round(gofs$oe_r_squ,2), 
                 predfid = round(gofs$pred_95,2))
  ft <- flextable::regulartable(ft)
  ft <- flextable::compose(ft, part = "header", j = 3,value = as_paragraph("R",as_sup("2")))
  ft <- flextable::compose(ft, part = "body", i = 5, j = 1,
                           value = as_paragraph("Minimum ϕ"))
  ft <- flextable::compose(ft, part = "body", i = 6, j = 1,
                           value = as_paragraph("Median ϕ"))
  ft <- flextable::italic(ft, part = "header", j = 3)
  ft <- flextable::set_header_labels(ft, values = list(predfid = "Prediction fidelity"))
  ft <- flextable::align(ft, align = "left", part = "all")
  ft <- flextable::valign(ft, valign = "top", part = "all")
  ft <- flextable::font(ft,fontname = "Helvetica", part = "all")
  ft <- flextable::fontsize(ft, size = 10, part = "all")
  ft <- flextable::padding(ft, padding.top = 2,  padding.bottom = 2, part = "all")
  ft <- flextable::autofit(ft)
  ft <- flextable::width(ft, width = dim(ft)$widths*6.5 /(flextable_dim(ft)$widths))
ft
```

For the environmental models, we formulated $\beta$ parameters (of fixed effects) with diffuse normal prior distributions (mean 0, sd 5). For the multi-taxon model, the parameters for each species were drawn from a from a common assemblage-level multivariate-Normal hyper-distribution as $\beta_{k,j} \sim \textrm{MVNormal}(\mu_k, \Omega)$, where $\mu_k$ is the estimated assemblage mean for the $\beta$ parameter $k$ and $\Omega$ is the estimated variance-covariance matrix with an LKJ prior with shape 2, and scale with an exponentially distributed prior with rate 1 [@mcelreath_2020; @stan_dev_team_2022]. For all models, the random-effect parameters for site ($\theta_{s}$), time ($\theta_{t}$) and sample ($\theta_{s,t}$) were drawn from normal hyper-distributions, with mean 0 and sd with a half-normal prior distribution (mean 0, sd 3); a distribution wide enough to cover feasible effect sizes while avoiding large values when the data provide little information on group-level variance [@stan_dev_team_2022].

For all models, we drew inference from 4 unthinned chains, taking 3,500--4,000 posterior samples from each chain and discarding the first 2,500 for the models of environmental variables, and 6,000 samples discarding the first 1,000 for the multi-taxon model. The retained samples were sufficient to ensure bulk and tail effective sample sizes of at least 100 per chain for all parameters. We diagnosed convergence of each model by visually inspecting the MCMC chains for adequate mixing and stationarity, and ensured that the diagnostic tests for zero-divergent transitions, zero cases of saturated tree-depth, Gelman-Rubin statistic ($\hat{R}$) \< 1.1, and Bayesian Fraction of Missing Information \>0.3, were satisfied.

### Models of environmental variables

The Before-After-Control-Impact effects on environmental variables were modeled assuming a normal distribution for each (appropriately transformed, Table 1) environmental variable. The Stan code for the model, `normal_rand_sa_si_t_fixedmatrix-baci.stan`, is reproduced below, with annotations defining variables and parameters, and explaining model components. Below that is the code used to load the data, run, check and evaluate the model for each variable, and produce output objects used to produce figures in the manuscript. Running all models took \~7 min.

#### Stan code

```{stan output.var = "env_mod"}
#| echo: true
#| eval: false

data {
  int<lower=0> n_obs;       // Number of observations (sample-units, s-u)
  int<lower=1> n_site;      // Number of sites
  int<lower=1> n_sample;    // Number of samples  (combinations of t_no, site_no)
  int<lower=1> n_pred;      // Number of predictor variables
  int<lower=1> n_t;         // Number of sampling occasions
  matrix[n_obs,n_pred] u;   // group predictors (model matrix) 
  array[n_obs] real y;      // Normally-distributed response variable
  array[n_obs] int site_no; // Site number
  array[n_obs] int samp_no; // Sample number (vectorised [t_no, site_no])
  array[n_obs] int t_no;    // sampling occasion number
}
parameters {
  vector[n_pred] gamma;        // beta parameters of fixed effects in u
  vector[n_site] a_s_raw;      // raw coefficient of random site effect 
  vector[n_t] a_t_raw;         // raw coefficient of time effect 
  vector[n_sample] a_st_raw;   // raw coefficient of random sample effect 
                               // (1 sample per site_no per t_no)
  // see reparameterizations below for explanation of these raw coefficients
  real<lower=0> sigma_s;       //sd of hyperdistribution of a_ss among taxa
  real<lower=0> sigma_t;       //sd of hyperdistribution of a_ts among taxa
  real<lower=0> sigma_st;      //sd of hyperdistribution of a_sts among taxa
  real<lower=0> sigma;         //sd of mu
}
transformed parameters {
  vector[n_obs] mu;          // Log total count
  vector[n_site] a_s;        // coefficient of random site effect
  vector[n_t] a_t;           // Coefficient of time effect 
  vector[n_sample] a_st;     // coefficient of random site effect
  
  a_s =  sigma_s * a_s_raw;  
  a_t =  sigma_t * a_t_raw;  
  a_st =  sigma_st * a_st_raw;  
// with (e.g.) a_s_raw ~ std_normal(), this implies a_s ~ normal(0, sigma_s)
// See https://mc-stan.org/docs/stan-users-guide/reparameterization.html

   for(i in 1:n_obs){
       //The linear model
  mu[i] = a_s[site_no[i]] + a_t[t_no[i]]  +  a_st[samp_no[i]] +  
          u[i,] * gamma; 
      }
}

model {
  // Priors
   a_s_raw ~ std_normal();
   a_t_raw ~ std_normal();  
   a_st_raw ~ std_normal();
   to_vector(gamma) ~ normal(0,5);
   sigma_s ~ normal(0,3);  
   sigma_t ~ normal(0,3); 
   sigma_st ~ normal(0,3);
   sigma ~ normal(0,3);

 // Likelihood
  for (i in 1 : n_obs) {
    target += normal_lpdf(y[i] | mu[i], sigma);
  }
}

```

#### Assembling data and model sampling: R code

The following code loads the above stan model, and then looping through the 7 environmental variables (including maximum $\Phi$, not presented in the manuscript), assembles the data for each model (reducing the data, where necessary to account for differences in the spread of the few missing data), samples the model, recording sampling diagnostics of sample, the model object and `cmdstanr` csv files holding the posterior draws (a method which requires less RAM than saving all draw data in the model object). The sampling diagnostics are saved in a single table `univar_diagnostics.csv`.

```{r}
#| label: assemble_data
#| echo: true
#| message: false
#| error: false

# load and check cmdstanr package
library(cmdstanr) # see https://mc-stan.org/cmdstanr/articles/cmdstanr.html
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
# Set random seed to ensure reproducible results
rand_seed = 9430570 

source("misc_functions.R") # for ct and unscale functions
#import tables "sites","samples","biota","taxon_all","taxa","higher_taxa","metadata"
dat_list <- rio::import_list("data/urban_riffle_experiment_data_for_model.xlsx")
list2env(dat_list,globalenv())
# The dataset contains samples from the segments upstream (U) and downstream (D) 
# of the riffle (putative or real) in each site for trip 1-4 (out of 6).  Given 
# the small effects in the 'riffle' segments (M), and the incomplete processing 
# of the U and L segments, only M samples are used in the analysis.
samples$seg <- substr(samples$old_samplecode,nchar(samples$old_samplecode)-1,
                      nchar(samples$old_samplecode)-1)
samples <- samples[samples$seg == "M",]

# Assemble random predictors (site_no, sample_no, t)
sites <- sites[order(sites$exp_treatment,sites$ai),]
sites$site_no <- 1:nrow(sites)
samples$site_no <- sites$site_no[match(samples$sitecode,sites$sitecode)]
samples$sample <- substr(samples$old_samplecode,1,nchar(samples$old_samplecode)-1)
sample_nos <- data.frame(sample = unique(samples$sample))
sample_nos$sample_no <- 1:nrow(sample_nos)
samples$sample_no <- sample_nos$sample_no[match(samples$sample, sample_nos$sample)]
samples$t_no <- as.numeric(substr(samples$old_samplecode, 1,1))

# Assemble fixed predictors (a1,a2, ci, ba1ci, ba2ci, i, ba1cii, ba2cii, spring) into a matrix, u
samples$ba <- as.numeric(as.numeric(substr(samples$old_samplecode,1,1)) %in% c(3,4)) 
samples$ba[as.numeric(as.numeric(substr(samples$old_samplecode,1,1))) %in% c(5,6)] <- 2
samples$ba <- factor(samples$ba)
# a1 and a2 are the two after periods treated as categories with b as a reference
samples$ci <- as.numeric(sites$exp_treatment[match(samples$sitecode,sites$sitecode)] == "riffle") 
# 0 = control, 1 = riffle
samples$ai <- sites$ai[match(samples$sitecode, sites$sitecode)]
i_scaled <- scale(log10(samples$ai*100 + 0.1))
samples$i <- as.vector(i_scaled)
samples$spring <- as.integer(substr(samples$old_samplecode,1,1) %in% c(1,3,5))
u <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i + spring, data = samples)
```

```{r}
#| label: sample_env_models
#| echo: true
#| message: false
#| error: false
#| eval: false

# Assemble transformed and scaled environmental variables to be modeled
ys <- list(
  depth_m_var = as.vector(scale(log(samples$depth_m_var + 1.75e-05))),
# min(samples$depth_m_var[!is.na(samples$depth_m_var) &
#     samples$depth_m_var > 0])  # 1.75e-05
  depth_m_mean = as.vector(scale(log(samples$depth_m_mean))),
  vel_m_s_var = as.vector(scale(log(samples$vel_m_s_var + 0.0007442))),
# min(samples$vel_m_s_var[!is.na(samples$vel_m_s_var) &
#     samples$vel_m_s_var > 0])  # 0.0007442
  vel_m_s_mean = as.vector(scale(log(samples$vel_m_s_mean))), 
  min_phi = as.vector(scale(samples$min_phi)),
  max_phi = as.vector(scale(samples$max_phi)),
  med_phi = as.vector(scale(samples$med_phi))
)

y_transform_pars <- data.frame(stat = names(ys)[1:length(ys)],
                               log = c(rep(TRUE,4),rep(FALSE,3)), 
                               log_add = c(1.75e-05,0,0.0007442,0,NA,NA,NA))

# Check stan model is up-to-date: if not, compile.
env_mod <- cmdstan_model("normal_rand_sa_si_t_fixedmatrix_baci.stan", pedantic = TRUE) 

 system.time({
univar_diagnostics <-
  data.frame(model = NA,divergences = NA,max_treedepth_exceedences = NA,
             min_bfmi = NA,max_bfmi = NA,max_rhat = NA,min_ess_bulk = NA,
             min_ess_tail = NA)[0,]

# Loop through the 7 environmental variables (including max Phi, not presented)
for(i in 1:length(ys)){
# remove NAs
  yi <- names(ys)[i]
samplesi <- samples[!is.na(samples[,yi]),]
ui <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, data = samplesi)
# and for sample no (as there a variable no. of missing samples)
sample_nos <- data.frame(sample = unique(samplesi$sample))
sample_nos$sample_no <- 1:nrow(sample_nos)
samplesi$sample_no <- sample_nos$sample_no[match(samplesi$sample, sample_nos$sample)]

# Data list for Stan
sdata <- list(n_obs = nrow(samplesi),
              n_site = nrow(sites),
              n_sample = nrow(sample_nos),
              n_pred = ncol(ui),
              n_t = max(samplesi$t),
              site_no = samplesi$site_no,
              samp_no = samplesi$sample_no,
              t_no = samplesi$t,
              u = ui,
              y = ys[[i]][match(samplesi$smpcode,samples$smpcode)]
)

stanfit_i <- env_mod$sample(data = sdata,
                        seed = rand_seed, chains = 4,
                        parallel_chains = 4, 
                        iter_warmup = 2500,
# adjustments to Stan settings to meet diagnostic criteria
                        adapt_delta = c(0.98,0.98,0.99,0.98,0.99,0.99,0.98)[i],
                        max_treedepth = c(10,12,10,10,14,14,10)[i],
                        iter_sampling = c(620,500,600,520,700,700,600)[i],
                        refresh = 120)
# #  save csv files rather than the model object to use less RAM
stanfit_i$save_output_files(
  dir = model_fit_dir,
  basename = paste0("fit_riffle_baci_", names(ys)[i]), timestamp = FALSE, random = FALSE)
stanfit_i$sampler_diagnostics()
saveRDS(stanfit_i, file = paste0(model_fit_dir,"fit_riffle_baci_", names(ys)[i], ".rds"))
stanfit_i$diagnostic_summary()
summ <- stanfit_i$summary() 
univar_diagnostics <- rbind(univar_diagnostics, data.frame(model = names(ys)[i],
                                 divergences = sum(stanfit_i$diagnostic_summary()$num_divergent),
                                 max_treedepth_exceedences = sum(stanfit_i$diagnostic_summary()$num_max_treedepth),
                                 min_bfmi = min(stanfit_i$diagnostic_summary()$ebfmi),
                                 max_bfmi = max(stanfit_i$diagnostic_summary()$ebfmi),
                                 max_rhat = max(summ$rhat,na.rm=TRUE),
                                 min_ess_bulk = min(summ$ess_bulk,na.rm=TRUE),
                                 min_ess_tail = min(summ$ess_tail,na.rm=TRUE)))
}
write.csv(univar_diagnostics, "small_data/univar_diagnostics.csv", row.names = F)
 }) # ~4 min
```

The following chunk loops through the seven environmental variables, loading the model object for that variable and extracting the posterior distributions of the model parameters. The parameter distributions are used to calculate a prediction for every sample in the data set. We compared these predictions to the observed mean values to assess model fit.

The predictors were assembled as the table, `predx`: the unique set of predictors (the full model including random variables) to permit prediction the mean value of the variable in each of the samples of the study: a data.frame with 14 predictors (columns) and 53 combinations of predictor values (one for each sample).

`predy_draws` is a data.frame with 51--53 columns (matching predx rows, varied because of two samples missing substrate data) and 2400 rows (600 samples times 4 chains): the posterior distribution of the predicted mean abundance for each `predx` value. The chunk also calculates resulting goodness of fit measures reported below (and in Table 1).

```{r}
#| label: env_gofs
#| echo: true
#| message: false
#| error: false
#| eval: false

system.time({
gofs <-data.frame(model = NA, oe_r_squ = NA, oe_slope = NA, pred_95 = NA, nrowpredx = NA)[0,]
for(i in 1:length(ys)){
# remove NAs
  yi <- names(ys)[i]
  # load model object and assemble sdata as above
  stanfit_i <- readRDS(paste0(model_fit_dir,"fit_riffle_baci_",names(ys)[i], ".rds"))
  samplesi <- samples[!is.na(samples[,yi]),]
  ui <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, data = samplesi)
  sample_nos <- data.frame(sample = unique(samplesi$sample))
  sample_nos$sample_no <- 1:nrow(sample_nos)
  samplesi$sample_no <- sample_nos$sample_no[match(samplesi$sample, sample_nos$sample)]
  sdata <- list(n_obs = nrow(samplesi), n_site = nrow(sites),
                n_sample = nrow(sample_nos),n_pred = ncol(ui),
                n_t = max(samplesi$t),site_no = samplesi$site_no,
                samp_no = samplesi$sample_no,t_no = samplesi$t,u = ui,
                y = ys[[i]][match(samplesi$smpcode,samples$smpcode)])
  # Extract the posterior distributions of the model parameters
  drawsi <- as.data.frame(stanfit_i$draws(format = "df", 
                          variables = c("a_s","a_st","gamma", "a_t",
                                        "sigma_s","sigma_t","sigma_st","sigma"))) 
  predx <- unique(cbind(samplesi[c("sample","site_no","sample_no","t_no")],ui))
  temp <- aggregate(sdata$y, by = list(sample = samplesi$sample),FUN = mean)
  # Predictions of y given the data using the full model
  predx$x <- temp$x[match(predx$sample, temp$sample)]
    predy_draws <-
      drawsi[grep("a_s",names(drawsi))][match(predx$site_no, 1:sdata$n_site)] +
      drawsi[grep("a_t",names(drawsi))][match(predx$t, 1:sdata$n_t)] +
      drawsi[grep("a_st",names(drawsi))][match(predx$sample_no, 1:sdata$n_sample)] +
      drawsi[,"gamma[1]"] %*% t(predx$`(Intercept)`) +
      drawsi[,"gamma[2]"] %*% t(predx$ba1) +
      drawsi[,"gamma[3]"] %*% t(predx$ba2) +
      drawsi[,"gamma[4]"] %*% t(predx$ci) +
      drawsi[,"gamma[5]"] %*% t(predx$i) + 
      drawsi[,"gamma[6]"] %*% t(predx$`ba1:ci`) +
      drawsi[,"gamma[7]"] %*% t(predx$`ba2:ci`) +
      drawsi[,"gamma[8]"] %*% t(predx$`ba0:ci:i`) + 
      drawsi[,"gamma[9]"] %*% t(predx$`ba1:ci:i`) +
      drawsi[,"gamma[10]"] %*% t(predx$`ba2:ci:i`) 
names(predy_draws) <- predx$sample
meansi <- apply(predy_draws, 2, FUN = mean)
cisi <- apply(predy_draws, 2, quantile, probs = c(0.025,0.975))
lmi <- lm(meansi ~ predx$x)
gofsi <- data.frame(model = names(ys)[i],
                   oe_r_squ = summary(lmi)$adj.r.squared,
                   oe_slope = lmi$coefficients[2],
                   pred_95 = 0,
                   nrowpredx = ncol(predy_draws))
for(j in 1:nrow(predx)){
  gofsi$pred_95 <- gofsi$pred_95 + 
    as.numeric(findInterval(predx$x[j], cisi[,j]) == 1)
  #This adds one if the observed value is between the two CIs
}
gofsi$pred_95 <- gofsi$pred_95/nrow(predx)
gofs <- rbind(gofs, gofsi)
}
write.csv(gofs, "small_data/env_gofs.csv", row.names = FALSE)
})  # 10 s
```

The following code extracts the posterior distribution of mean abundance for each taxon in samples across the gradient of imperviousness for all combinations of the binary variables *B, A1, A2*, and *R*; *I* = minimum and maximum values in dataset (=4% and 32% EI), omitting random sample, site and t errors (For counterfactual plots used in the paper, demonstrating effect of riffle emplacement under different levels of urban impact), and the primary differences of interest in the BACI design:

1.  (control minus impact before \[B\]) - (control minus impact in first year after \[A1\]) for low (minimum) *I*

2.  (control minus impact before \[B\]) - (control minus impact 5-6 y after \[A2\]) for low *I*

3.  (control minus impact before \[B\]) - (control minus impact in first year after \[A1\]) for high *I*

4.  (control minus impact before \[B\]) - (control minus impact 5-6 y after \[A2\]) for high *I*

Note that, in the code, the fixed effects are assembled using R's model.matrix function, such that B = ba0, A1 = ba1, A2 = ba2, R = ci. The code saves a table `env_diff_summs.csv` used to plot Figure 2 in the paper.

```{r}
#| label: env_diff_summs
#| echo: true
#| message: false
#| error: false
#| eval: false

system.time({
cfs <- list()
for(i in 1:length(ys)){
# remove NAs
yi <- names(ys)[i]
# load model object compiled above
stanfit_i <- readRDS(paste0(model_fit_dir,"fit_riffle_baci_",names(ys)[i], ".rds"))
drawsi <- as.data.frame(stanfit_i$draws(format = "df", 
                        variables = c("a_s","a_st","gamma", "a_t",
                                      "sigma_s","sigma_t","sigma_st","sigma"))) 
samplesi <- samples[!is.na(samples[,yi]),]
ui <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, data = samplesi)
predx_cf <- expand.grid(intercept = 1, ba = factor(c(0,1,2)), ci = c(0,1), 
                        i = seq(min(ui[,5]),max(ui[,5]),length=10))
predx_cf <- data.frame(model.matrix(~ ba + ci + ba:ci + i + ba:ci:i, 
                                    data = predx_cf))
names(predx_cf) <- names(as.data.frame(ui))
predx_cf$ai <- 10^(predx_cf$i * attr(i_scaled, 'scaled:scale') + 
                     attr(i_scaled, 'scaled:center')) - 0.1
cf_drawsi <- 
      drawsi[,"gamma[1]"] %*% t(predx_cf$`(Intercept)`) +
      drawsi[,"gamma[2]"] %*% t(predx_cf$ba1) +
      drawsi[,"gamma[3]"] %*% t(predx_cf$ba2) +
      drawsi[,"gamma[4]"] %*% t(predx_cf$ci) +
      drawsi[,"gamma[5]"] %*% t(predx_cf$i) + 
      drawsi[,"gamma[6]"] %*% t(predx_cf$`ba1:ci`) +
      drawsi[,"gamma[7]"] %*% t(predx_cf$`ba2:ci`) +
      drawsi[,"gamma[8]"] %*% t(predx_cf$`ba0:ci:i`) + 
      drawsi[,"gamma[9]"] %*% t(predx_cf$`ba1:ci:i`) +
      drawsi[,"gamma[10]"] %*% t(predx_cf$`ba2:ci:i`) 

cfs[[i]] <- cfi <- 
  data.frame(predx_cf, 
             mean = apply(cf_drawsi,2, mean),
             t(as.data.frame(apply(cf_drawsi, 2,
                                    quantile, probs = c(0.025,0.05,0.5,0.95,0.975)))))
names(cfs)[i] <- names(ys)[i]
# the 12 scenarios for calculating differences  
combos <- list(control_hii = which(cfi$ci == 0 & cfi$i == max(cfi$i)),
                 impact_hii = which(cfi$ci == 1 & cfi$i == max(cfi$i)),
                 control_lowi = which(cfi$ci == 0 & cfi$i == min(cfi$i)),
                 impact_lowi = which(cfi$ci == 1 & cfi$i == min(cfi$i)))
env_diffs_i <- baci_diffs(cf_drawsi)
meani = apply(env_diffs_i, 2, FUN = mean)
qlsi <- as.data.frame(t(apply(env_diffs_i, 2, FUN = quantile, 
      probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
meani <- apply(env_diffs_i,2, FUN = mean)
if(i == 1){
  env_diff_summs <- data.frame(stat = names(cfs)[i],
                                  diff = row.names(qlsi), mean = meani, qlsi)
}else{
  env_diff_summs <- rbind(env_diff_summs,
                          data.frame(stat = names(cfs)[i],
                                     diff = row.names(qlsi), mean = meani, qlsi))
}
}
write.csv(env_diff_summs, "small_data/env_diff_summs.csv", row.names = FALSE)
WriteXLS::WriteXLS(cfs, "small_data/env_var_predy_cf.xlsx")
}) # 8 s
```

### The multi-taxon model

The Before-After-Control-Impact effects on count per sample unit of the 113 macroinvertebrate taxa were modeled as a multi-taxon model, assuming a negative binomial distribution of counts, and binomially distributed subsampling error. The Stan code for the model, `nbinom_me_rand_sa_si_t_fixedmatrix-baci.stan`, is reproduced below, with annotations defining variables and parameters, and explaining model components. Below that is the code used to load the data, run, check and evaluate the model, and produce output objects used to produce figures in the manuscript. The multi-taxon model took 4 h to run on a 2.6-GHz system on 4 parallel cores, and compilation of the parameter draws required \~40 Gb RAM.

#### Stan code

```{stan output.var = "mt_mod"}
#| echo: true
#| eval: false

data {
  int<lower=0> n_obs;         // Number of observations (sample-units, s-u)
  int<lower=1> n_taxa;        // Number of taxa
  int<lower=1> n_site;        // Number of sites
  int<lower=1> n_sample;      // Number of samples (combinations of t_no, site_no)
  int<lower=1> n_pred;        // Number of predictor variables
  int<lower=1> n_t;           // Number of sampling occasions
  matrix[n_obs,n_pred] u;     // group predictors (model matrix) 
  array[n_obs,n_taxa] int c;  // Count of each taxon in each subsample
  array[n_obs,n_taxa] real s; // Subsample proportion for each s-u
  array[n_obs] int site_no;   // Site number
  array[n_obs] int samp_no;   // Sample number (vectorised [t_no, site_no])
  array[n_obs] int t_no;      // Sampling occasion number
}
parameters {
  vector[n_pred] mu_gamma;         //means of beta parameter hyperdistributions          
  matrix[n_pred,n_taxa] gamma;        // beta parameters of fixed effects in u
  matrix[n_site,n_taxa] a_s_raw;      // raw coefficient of random site effect
  matrix[n_t,n_taxa] a_t_raw;         // raw oefficient of time effect 
  matrix[n_sample,n_taxa] a_st_raw;   // raw coefficient of random sample effect 
                                      //(1 sample per site_no per t_no)
  // see reparameterizations below for explanation of these raw coefficients
  vector<lower=0>[n_taxa] sigma_s; //rsd of hyperdistribution of a_ss among taxa
  vector<lower=0>[n_taxa] sigma_t; //sd of hyperdistribution of a_ts among taxa
  vector<lower=0>[n_taxa] sigma_st;//sd of hyperdistribution of a_sts among taxa
  vector<lower=0>[n_taxa] inv_phi; //inverse-square of dispersion parameter for neg-binomial distn
  real<lower=0> mu_inv_phi;        // see phi, below
  real<lower=0> sd_inv_phi;        // see phi, below
  corr_matrix[n_pred] Omega;       // Hyperprior correlation matrix among taxa
  vector<lower=0>[n_pred] tau;     // Scale for correlation matrix
}
transformed parameters {
  matrix[n_obs,n_taxa] log_lambda;  // Log total count
  matrix[n_site,n_taxa] a_s;        // coefficient of random site effect
  matrix[n_t,n_taxa] a_t;           // Coefficient of random time effect 
  matrix[n_sample,n_taxa] a_st;     // coefficient of random sample effect
                         // (sample = 3-4 s-us from each site on each occasion)
  vector<lower=0>[n_taxa] phi;     //dispersion parameter for neg-binomial distn

  for(j in 1:n_taxa){
  a_s[,j] =  sigma_s[j] * a_s_raw[,j];  
  a_t[,j] =  sigma_t[j] * a_t_raw[,j];  
  a_st[,j] =  sigma_st[j] * a_st_raw[,j];  
  }
// with (e.g.) a_s_raw ~ std_normal(), this implies a_s ~ normal(0, sigma_s)
// See https://mc-stan.org/docs/stan-users-guide/reparameterization.html

   phi = pow(1/inv_phi,2);         
// see https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations

  for(i in 1:n_obs){
     for(j in 1:n_taxa){
       //The linear model
      log_lambda[i,j] = a_s[site_no[i],j] +  a_t[t_no[i],j] +  
                       a_st[samp_no[i],j] +  u[i,] * gamma[,j]; 
      }
      }
}

model {
  // Priors
   mu_gamma ~ normal(0,5);
   to_vector(a_s_raw) ~ std_normal();
   to_vector(a_t_raw) ~ std_normal();
   to_vector(a_st_raw) ~ std_normal();
   sigma_s ~ normal(0,3);
   sigma_t ~ normal(0,3);
   sigma_st ~ normal(0,3);
   inv_phi ~ normal(mu_inv_phi, sd_inv_phi);
   mu_inv_phi ~ normal(0,5);
   sd_inv_phi ~ normal(0,5);
   tau ~ exponential(1);
   Omega ~ lkj_corr( 2 );  
   
   // estimation of correlated beta parameters (assembled in matrix gamma)
   for(i in 1:n_taxa){
   target += multi_normal_prec_lpdf(gamma[,i] | mu_gamma, quad_form_diag(Omega, 
                                                                         tau) );
     }
  // Likelihood
  for (i in 1 : n_obs) {
    for(j in 1:n_taxa){
    target += neg_binomial_2_log_lpmf(c[i,j] | log_lambda[i,j] + log(s[i,j]), 
                                      phi[j]);
  // This parameterization adds the marginal log-binomial-probability 
  // resulting from subsampling error to the marginal negative-binomial 
  // probability of the linear model.  It is equivalent to a (50 times) slower 
  // parameterization modelling the marginal binomial and negative-binomial
  // probabilities separately, by looping through all feasible total counts
  // given each count and subsample proportion.
   }
  }
}

// generated quantities {
//   // log-likelihood only used for model comparisons during model development.
//   // The most complex model considered has been used, 
//   // so model comparisons not reported
//   array[n_obs,n_taxa] real log_lik;  
//  for (i in 1 : n_obs) {
//    for(j in 1 : n_taxa){
//    log_lik[i,j] = neg_binomial_2_log_lpmf(c[i,j] | log_lambda[i,j] + 
//                     log(s[i,j]), phi[j]);
//  }
//  }
//  }

```

#### Assembling data and model sampling: R code

The following code assembles the biotic data for the multi-taxon model, creating a list `mt_data`.

```{r}
#| label: assemble_biotic_data
#| echo: true
#| message: false
#| error: false

# biota, samples etc compiled above in chunk assemble_data
biota <- biota[biota$smpcode %in% samples$smpcode,]
# Convert long-form biota table into a wide taxon-by-sample table of counts 
# in subsamples
biota_ct <- as.data.frame(ct(biota$smpcode, biota$shortcode, biota$count))
biota_ct <- biota_ct[match(samples$smpcode,row.names(biota_ct)),]
# Create a table of the same dimensions as biota_ct, with the subsample proportion
# for each observation (for coarsepick specimens, subsample ppn = 1)
ss_ct <- biota_ct
for(i in 1:nrow(samples)){
  ss_ct[i,] <- samples$subsample_perc[i]/100
}
for(i in which(biota$coarsepick == 1)){
  ss_ct[row.names(ss_ct) == biota$smpcode[i], biota$shortcode[i]] <- 1
}

# data list for Stan multi-taxon model
mt_data <- list(n_obs = nrow(biota_ct),
              n_taxa = ncol(biota_ct),
              n_site = nrow(sites),
              n_sample = length(unique(samples$sample_no)),
              n_pred = ncol(u),
              n_t = max(samples$t),
              site_no = samples$site_no,
              samp_no = samples$sample_no,
              t_no = samples$t_no,
              u = u,
              c = as.matrix(biota_ct),
              s = as.matrix(ss_ct)
)
```

The following samples the model, checks sampling diagnostics of sample, and saves the model object and `cmdstanr` csv files holding the posterior draws. It extracts the posterior distributions of the model parameters, saving them as an rdata object, `fit_riffle_baci_draws.rda`.

```{r}
#| label: sample_mt_model
#| echo: true
#| message: false
#| error: false
#| eval: false

# Check model is up-to-date: if not, compile.
mod <- cmdstan_model("nbinom_me_rand_sa_si_t_fixedmatrix_baci.stan", pedantic = TRUE) 
stanfit_i <- mod$sample(data = mt_data,
                        seed = rand_seed, chains = 4,
                        parallel_chains = 4, iter_warmup = 1000,
                        adapt_delta = 0.95,
                        iter_sampling = 5000, refresh = 120) 
# 6000 iterations took ~5 h
# #  save csv files rather than the model object to use less RAM
stanfit_i$save_output_files(dir = model_fit_dir, basename = "fit_riffle_baci_mt", 
                            timestamp = FALSE, random = FALSE)
stanfit_i$sampler_diagnostics()
saveRDS(stanfit_i, file = paste0(model_fit_dir,"fit_riffle_baci_mt.rds"))
stanfit_i$diagnostic_summary()
# EBFMI 0.37, 0.39, 0.36, 0.42; 0 divergences; 0 maximum tree-depth reached.
# # The above three steps required < 500 Mb RAM
summ <- stanfit_i$summary() # took an additional 24 min and needed >40 Gb RAM
min(summ$ess_bulk,na.rm=TRUE) # 461
min(summ$ess_tail,na.rm=TRUE) # 828
max(summ$rhat,na.rm=TRUE)  # 1.015
# # all diagnostic_summary diagnostics were satisfied

mod_draws <- as.data.frame(stanfit_i$draws(format = "df", variables = c("a_s",
                    "a_t","a_st","gamma","phi","sigma_s","sigma_t","sigma_st",
                    "inv_phi","mu_inv_phi","sd_inv_phi")))
save(mod_draws, file = paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
```

The following uses the posterior distributions of the model parameters to predict mean abundance and of each taxon in each sample, and the mean count in each sample given the subsample fraction (for assessment of model fit, below), using the unique predictor combinations of all samples in the dataset (`predx`, described above) The resulting objects `predy_draws` (for abundances) and `pred_c_draws` (for counts) are lists of 113 elements (one for each taxon; the name of each element = the relevant taxoncode). Each element is a data.frame with 53 columns (matching predx rows) and 20000 rows (5000 samples times 4 chains): the posterior distribution of the predicted mean abundance of each taxon for each `predx` value. `param_summs` is a list of summary tables of quantiles of the posterior predicted distribution of each fixed parameter for each taxon, saved as `param_summs.xlsx`, with 113 sheets containing the table for each taxon.

```{r}
#| label: predy_summary
#| echo: true
#| eval: false

# load draws of parameters from model if necessary (object mod_draws calculated above)
# load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
predx <- unique(cbind(samples[c("sample","site_no","sample_no","t_no")],u))

# Generate posterior prediction distributions of mu for each sample (mean(log abundance))
predy_draws <- list()
system.time({
for(i in 1:mt_data$n_taxa){
  drawsi <- mod_draws[grep(paste0(",",i,"]"), names(mod_draws))]
  predy_draws[[i]] <-
    drawsi[substr(names(drawsi),1,3) == "a_s"][match(predx$site_no, 1:mt_data$n_site)] +
    drawsi[substr(names(drawsi),1,3) == "a_t"][match(predx$t, 1:mt_data$n_t)] +
    drawsi[substr(names(drawsi),1,4) == "a_st"][match(predx$sample_no, 1:mt_data$n_sample)] +
      drawsi[,paste0("gamma[1,",i,"]")] %*% t(predx$`(Intercept)`) +
       drawsi[,paste0("gamma[2,",i,"]")] %*% t(predx$ba1) +
       drawsi[,paste0("gamma[3,",i,"]")] %*% t(predx$ba2) +
       drawsi[,paste0("gamma[4,",i,"]")] %*% t(predx$ci) +
       drawsi[,paste0("gamma[5,",i,"]")] %*% t(predx$i) + 
       drawsi[,paste0("gamma[6,",i,"]")] %*% t(predx$spring) +
       drawsi[,paste0("gamma[7,",i,"]")] %*% t(predx$`ba1:ci`) +
       drawsi[,paste0("gamma[8,",i,"]")] %*% t(predx$`ba2:ci`) +
       drawsi[,paste0("gamma[9,",i,"]")] %*% t(predx$`ba0:ci:i`) + 
       drawsi[,paste0("gamma[10,",i,"]")] %*% t(predx$`ba1:ci:i`) +
       drawsi[,paste0("gamma[11,",i,"]")] %*% t(predx$`ba2:ci:i`) 
}
})  # 1 min
names(predy_draws) <- colnames(mt_data$c)
save(predy_draws, file = paste0(model_fit_dir,"fit_riffle_baci_predy_draws.rda"))

# # Generate posterior prediction distributions of c: needs to be done at the sample-unit scale to account for variation in s
phi_draws <- mod_draws[,substr(names(mod_draws),1,3) == "phi"]
pred_c_draws_su <- list()

for(i in 1:mt_data$n_taxa){
  ci <- data.frame(matrix(nrow = nrow(phi_draws[1]),ncol= mt_data$n_obs))
  names(ci) <- samples$smpcode
  for(j in 1:mt_data$n_obs){
      Y_ij_draws <- rnbinom(nrow(phi_draws[i]),
                mu = exp(predy_draws[[colnames(mt_data$c)[i]]][,sample_nos$sample == samples$sample[j]]),
                size = phi_draws[i][,1])
      ci[,j] <- rbinom(nrow(phi_draws[i]), Y_ij_draws, mt_data$s[j,i])
  }
  pred_c_draws_su[[i]] <- ci
}
names(pred_c_draws_su) <- names(mt_data$c)

pred_c_draws <- list()
for(i in 1:mt_data$n_taxa){
  ci <- aggregate(t(pred_c_draws_su[[i]]), by = list(sample = samples$sample), FUN = sum)
  pred_c_draws[[i]] <- t(ci[,-1])
}
save(pred_c_draws, file = paste0(model_fit_dir,"pred_c_draws.rda"))

# Summarise posterior predicted distribution of each fixed parameter
params <- c("b_ba1", "b_ba2", "b_ci","b_i","b_spring","b_ba1ci","b_ba2ci","b_ba0cii","b_ba1cii", "b_ba2cii")
df_empty <- data.frame(shortcode = NA, mean = NA, lo95 = NA, lo90 = NA, median = NA, hi90 = NA, hi95 = NA)[0,]
mod_draws <- get(load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda")))
param_summs <- list()
for(i in 1:length(params)){
  drawsi <- mod_draws[substr(names(mod_draws),1,ifelse(i < 9, 7, 8)) == paste0("gamma[", i + 1) & 
                          grepl("gamma", names(mod_draws))]
  qlsi <- as.data.frame(t(apply(drawsi,2, FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- apply(drawsi,2, FUN = mean)
  param_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(param_summs) <- params
WriteXLS::WriteXLS(param_summs, "small_data/param_summs.xlsx")
```

The following extracts the posterior distribution of mean abundance for each taxon in samples across the gradient of imperviousness for all combinations of the BACI effects and high and low values of *I*, as described above for the environmental variable models, and with the season effect S = 0 (i.e. autumn), omitting random sample, site and t errors. It then calculates the differences to detect an effect of the riffles as described above for the environmental variable models.

```{r}
#| label: pred_cf
#| echo: true
#| eval: false

# load draws of parameters from model if necessary (object mod_draws calculated above)
#load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))

# predx_cf is the table of scenario predictor variables for counterfactual plots/analysis
# predy_cf is a list with 113 elements, one for each taxon (each element has a taxoncode as a name)
# each element is a table of posterior distributions (32000 draws in rows) for the 60 scenarios (in columns)
predx_cf <- expand.grid(intercept = 1, ba = factor(c(0,1,2)), ci = c(0,1), 
                        i = seq(min(u[,5]),max(u[,5]),length=10), spring = 0)
predx_cf <- data.frame(model.matrix(~ ba + ci + ba:ci + i + ba:ci:i + spring, 
                                    data = predx_cf))
predx_cf$ai <- 10^(predx_cf$i * attr(i_scaled, 'scaled:scale') + 
                attr(i_scaled, 'scaled:center')) - 0.1
predy_cf <- delta_baci1_low <- delta_baci2_low <- delta_baci1_hi <- delta_baci2_hi <- list()

# As for the environmental variables, the 12 scenarios for calculating differences  
combos <- list(control_hii = which(predx_cf$ci == 0 & predx_cf$i == max(predx_cf$i)),
               impact_hii = which(predx_cf$ci == 1 & predx_cf$i == max(predx_cf$i)),
               control_lowi = which(predx_cf$ci == 0 & predx_cf$i == min(predx_cf$i)),
               impact_lowi = which(predx_cf$ci == 1 & predx_cf$i == min(predx_cf$i)))

system.time({
for(i in 1:mt_data$n_taxa){
  drawsi <- mod_draws[grep(paste0(",",i,"]"), names(mod_draws))]
  predy_cf[[i]] <-
       drawsi[,paste0("gamma[1,",i,"]")] %*% t(predx_cf$X.Intercept.) +
       drawsi[,paste0("gamma[2,",i,"]")] %*% t(predx_cf$ba1) +
       drawsi[,paste0("gamma[3,",i,"]")] %*% t(predx_cf$ba2) +
       drawsi[,paste0("gamma[4,",i,"]")] %*% t(predx_cf$ci) +
       drawsi[,paste0("gamma[5,",i,"]")] %*% t(predx_cf$i) + 
       drawsi[,paste0("gamma[6,",i,"]")] %*% t(predx_cf$spring) +
       drawsi[,paste0("gamma[7,",i,"]")] %*% t(predx_cf$ba1.ci) +
       drawsi[,paste0("gamma[8,",i,"]")] %*% t(predx_cf$ba2.ci) +
       drawsi[,paste0("gamma[9,",i,"]")] %*% t(predx_cf$ba0.ci.i) + 
       drawsi[,paste0("gamma[10,",i,"]")] %*% t(predx_cf$ba1.ci.i) +
       drawsi[,paste0("gamma[11,",i,"]")] %*% t(predx_cf$ba2.ci.i) 
}
names(predy_cf) <- names(biota_ct)
 
for(i in 1:mt_data$n_taxa){
delta_baci1_low[[i]] <- predy_cf[[i]][,combos$control_lowi[1]] - predy_cf[[i]][,combos$impact_lowi[1]] -
                    (predy_cf[[i]][,combos$control_lowi[2]] - predy_cf[[i]][,combos$impact_lowi[2]])
delta_baci2_low[[i]] <- predy_cf[[i]][,combos$control_lowi[1]] - predy_cf[[i]][,combos$impact_lowi[1]] -
                    (predy_cf[[i]][,combos$control_lowi[3]] - predy_cf[[i]][,combos$impact_lowi[3]])
delta_baci1_hi[[i]] <- predy_cf[[i]][,combos$control_hii[1]] - predy_cf[[i]][,combos$impact_hii[1]] -
                    (predy_cf[[i]][,combos$control_hii[2]] - predy_cf[[i]][,combos$impact_hii[2]])
delta_baci2_hi[[i]] <- predy_cf[[i]][,combos$control_hii[1]] - predy_cf[[i]][,combos$impact_hii[1]] -
                    (predy_cf[[i]][,combos$control_hii[3]] - predy_cf[[i]][,combos$impact_hii[3]])
}
})  # 5 s

# summary table of percentiles for all species for 12 scenarios used for 
# inference of baci effect
taxon_abun_cf_summs <- list()
for(i in unlist(combos)){
  list_index <- which(unlist(combos) == i)
  tabi <- data.frame(taxoncode = names(predy_cf), 
                     mean = NA, "lo95" = NA, "lo90"= NA, "lo75" = NA,
                    "median" = NA,"hi75" = NA,"hi90" = NA,"hi95" = NA)
  for(j in 1:length(predy_cf)){
    tabi$mean[j] <- mean(predy_cf[[j]][,i])
    tabi[j,-(1:2)] <- quantile(predy_cf[[j]][,i], 
                             probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))
  }
  taxon_abun_cf_summs[[list_index]] <- tabi
}
names(taxon_abun_cf_summs) <- names(unlist(combos))
WriteXLS::WriteXLS(taxon_abun_cf_summs, "small_data/taxon_abun_cf_summs.xlsx")

# delta_posts takes 12 of the scenarios and calculates four differences used as 
# evidence of riffle effect. It is a list of four lists (one for each difference).
# Each difference has 113 elements (taxa, as above) and each element is a vector 
# length 32000 of the posterior distribution of the diffence for each taxon.
  delta_posts <- list(delta_a1_4ei = delta_baci1_low, 
                    delta_a2_4ei = delta_baci2_low, 
                    delta_a1_32ei = delta_baci1_hi, 
                    delta_a2_32ei = delta_baci2_hi)
save(predy_cf, delta_posts, 
     file = paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

diff_summs <- list()
for(i in 1:length(delta_posts)){
  qlsi <- as.data.frame(do.call(rbind,lapply(delta_posts[[i]],FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- unlist(lapply(delta_posts[[i]],FUN = mean))
  diff_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(diff_summs) <- names(delta_posts)
WriteXLS::WriteXLS(diff_summs, "small_data/diff_summs.xlsx")
```

```{r}
#| label: calc_assemb_stats
#| echo: false
#| eval: false

# load draws of parameters from model (from above) if necessary
# load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
# load taxon abundance predictions for 60 counter-factual scenarios (from above) if necessary
load(paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

phi_draws <- mod_draws[,substr(names(mod_draws),1,3) == "phi"]
pa_cf_mat <- p_cf_mat <- n_cf_mat <- list()

# And use them to calculate assemblage statistics

# system.time({
for(t in 1:ncol(biota_ct)){
p_cf_mat[[t]] <- predy_cf[[t]]
n_cf_mat[[t]] <- exp(predy_cf[[t]])
for(i in 1:ncol(p_cf_mat[[t]]))
  # Probability of occurrence in 1 sample unit
p_cf_mat[[t]][,i] <- 1 - pnbinom(0,mu = exp(predy_cf[[t]][,i]),
                                 size = phi_draws[,t])
  # Probability of occurrence in 4 sample units
p_cf_mat[[t]] <- 1 - (1 - p_cf_mat[[t]])^4
  # back-transformed abundance per 4 samples
}
# }) # ~15 s

names(p_cf_mat) <- colnames(biota_ct)
tot_rich_cf_mat <- Reduce('+', p_cf_mat)
# see https://stackoverflow.com/questions/11641701/sum-a-list-of-matrices
ept_rich_cf_mat <- Reduce('+', p_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QE","QP","QT")])
do_rich_cf_mat <- Reduce('+', p_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QD","LO")])

tot_n_cf_mat <- Reduce('+', n_cf_mat)
ept_n_cf_mat <- Reduce('+', n_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QE","QP","QT")])
do_n_cf_mat <- Reduce('+', n_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QD","LO")])

library(vegan)

# Shannon's H' requires proportional abundances
relab_cf_mat <- n_cf_mat
tot_abund_cf_mat <- Reduce('+', n_cf_mat)
for(i in 1:length(n_cf_mat)){
relab_cf_mat[[i]] <- relab_cf_mat[[i]] / tot_abund_cf_mat
}

H_mat <- relab_cf_mat[[1]]
for(i in 1:nrow(H_mat)){
H_mat[i,] <- diversity(sapply(relab_cf_mat,function(x, n) x[n,],i))
}

# Pielou's Evenness
evenness_cf_mat <- H_mat/log(tot_rich_cf_mat)

# Reduce set to family-presence absence for SIGNAL calculation
biotic_indices<- 
  read.csv("small_data/biotic_indices.csv")
signal <- biotic_indices[!is.na(biotic_indices$SIGNALWoV2003),
                         c("shortcode","taxon","SIGNALWoV2003")]
signal <- signal[signal$shortcode %in%
                             c("LO",substr(names(biota_ct),1,4)),]
signal <- signal[order(signal$shortcode),]
signal_mat <- list()
for(i in 1:nrow(signal)){
  ss <- ifelse(signal$shortcode[i] == "LO",
               which(substr(names(p_cf_mat),1,2) == "LO"),
               which(substr(names(p_cf_mat),1,4) %in% signal$shortcode[i]))
  # probability of occurrence of taxon i (lumping oligochaetes)
  signal_mat[[i]] <-
    Reduce(function(x) 1-(1-x)^length(ss), p_cf_mat[ss])
  # convert signal_mat to presence-absence
  signal_mat[[i]] <- matrix(unlist(Map(function(x) rbinom(1,1,x),
                            signal_mat[[i]])),ncol = ncol(p_cf_mat[[1]]))
  signal_mat[[i]][signal_mat[[i]] > 0] <-
    signal_mat[[i]][signal_mat[[i]] > 0]* signal$SIGNALWoV2003[i]
}
signal_sum_cf_mat <- Reduce('+', signal_mat)
signal_len_cf_mat <- Reduce('+', lapply(signal_mat, function(x)
                      replace(x, x > 0, 1)))
signal_cf_mat <- signal_sum_cf_mat/signal_len_cf_mat

baci_diffs <- function(mat){
  data.frame(delta_baci1_low = 
               mat[,combos$control_lowi[1]] - mat[,combos$impact_lowi[1]] -
                    (mat[,combos$control_lowi[2]] - mat[,combos$impact_lowi[2]]),
             delta_baci2_low = 
               mat[,combos$control_lowi[1]] - mat[,combos$impact_lowi[1]] -
                    (mat[,combos$control_lowi[3]] - mat[,combos$impact_lowi[3]]),
             delta_baci1_hi =
               mat[,combos$control_hii[1]] - mat[,combos$impact_hii[1]] -
                    (mat[,combos$control_hii[2]] - mat[,combos$impact_hii[2]]),
             delta_baci2_hi = mat[,combos$control_hii[1]] - mat[,combos$impact_hii[1]] -
                    (mat[,combos$control_hii[3]] - mat[,combos$impact_hii[3]]))
}

assemb_stats <- list(tot_rich = 
                       data.frame(mean =apply(tot_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(tot_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     shannon_h = 
                       data.frame(mean =apply(H_mat,2, 
                                              FUN = mean),
                                  t(apply(H_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     evenness = 
                       data.frame(mean =apply(evenness_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(evenness_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     ept_rich = 
                       data.frame(mean =apply(ept_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(ept_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     do_rich = 
                       data.frame(mean = apply(do_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(do_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     signal = 
                       data.frame(mean =apply(signal_cf_mat,2, 
                                              FUN = mean, na.rm = TRUE),
                                  t(apply(signal_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975), 
                                          na.rm = TRUE))),
                     tot_n = 
                       data.frame(mean =apply(tot_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(tot_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     ept_n = 
                       data.frame(mean =apply(ept_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(ept_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     do_n = 
                       data.frame(mean =apply(do_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(do_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975))))
                     )
WriteXLS::WriteXLS(assemb_stats, "small_data/assemb_stat_summs.xlsx")

assemb_stat_diffs <- list(signal = baci_diffs(signal_cf_mat),
                          evenness = baci_diffs(evenness_cf_mat),
                          H = baci_diffs(H_mat),
                          tot_rich = baci_diffs(tot_rich_cf_mat),
                          ept_rich = baci_diffs(ept_rich_cf_mat),
                          do_rich = baci_diffs(do_rich_cf_mat),
                          tot_n = baci_diffs(tot_n_cf_mat),
                          ept_n = baci_diffs(ept_n_cf_mat),
                          do_n = baci_diffs(do_n_cf_mat))
save(assemb_stat_diffs, file =paste0(model_fit_dir,"assemb_stat_diffs.rda"))

assemb_stat_diffs <-  assemb_stat_diffs[match(c("tot_rich","ept_rich","do_rich",
                                                "signal","tot_n","ept_n","do_n","H","evenness"),
                                              names(assemb_stat_diffs))]
for(i in 1:length(assemb_stat_diffs)){
  drawsi <- assemb_stat_diffs[[i]]
  qlsi <- as.data.frame(t(apply(drawsi,2, FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- apply(drawsi,2, FUN = mean)
  if(i == 1){
  assemb_stat_diff_summs <- data.frame(stat = names(assemb_stat_diffs)[i],
                                       diff = row.names(qlsi), mean = meani, qlsi)
             }else{
  assemb_stat_diff_summs <- rbind(assemb_stat_diff_summs,
                                   data.frame(stat = names(assemb_stat_diffs)[i],
                                               diff = row.names(qlsi), 
                                              mean = meani, qlsi))
                    }
}
WriteXLS::WriteXLS(assemb_stat_diff_summs, "small_data/assemb_stat_diff_summs.xlsx")

# Extract mean abundances in the 12 main scenarios for the top 10 taxa in each scenario
# (For table 1 in the manuscript)
relabunds <- data.frame(scenario = names(unlist(combos)),
                        matrix(nrow = length(unlist(combos)),
                               ncol = length(relab_cf_mat)))
names(relabunds)[-1] <- colnames(mt_data$c)
for(i in 1:length(relab_cf_mat)){
  relabunds[,i + 1] <- apply(relab_cf_mat[[i]][,unlist(combos)],2,FUN = mean)
}
top10_propns <- data.frame(scenario = relabunds$scenario, propn = NA)
top10s <- list()
for(i in 1:nrow(relabunds)){
  rai <- t(relabunds[i,-1])
  top10s[[i]] <- row.names(rai)[order(rai, decreasing =  TRUE)[1:10]]
  top10_propns[i,2] <- sum(rai[order(rai, decreasing =  TRUE)[1:10]])
}
tops <- data.frame(taxoncode = c(unique(unlist(top10s[])),NA),
                   Taxon = c(taxa$taxon[match(unique(unlist(top10s[])), 
                                                       taxa$taxoncode)],"% of all taxa"),
                   High.I_Control_B = NA, High.I_Control_A1 = NA, High.I_Control_A2 = NA, 
                   High.I_Impact_B = NA, High.I_Impact_A1 = NA, High.I_Impact_A2 = NA, 
                   Low.I_Control_B = NA, Low.I_Control_A1 = NA, Low.I_Control_A2 = NA, 
                   Low.I_Impact_B = NA, Low.I_Impact_A1 = NA, Low.I_Impact_A2 = NA)
for(i in 1:(nrow(tops)-1)){
  tops[i,-(1:2)] <- round(apply(n_cf_mat[[which(colnames(mt_data$c) == tops$taxoncode[i])]][,unlist(combos)],
                          2,FUN = mean))
}
tops[nrow(tops),-(1:2)] <- round(top10_propns$propn*100)
write.csv(tops,"small_data/top10taxa.csv",row.names = FALSE)
```

## 2. Assessment of model fit

We assessed the predictive performance of our model by comparing model predictions for each sample (combining predictions for the sample_units taken at each site on each occasion) using the full model, including the random effects $\theta_1$, $\theta_2$, and $\theta_3$. For the multi-taxon model, we assessed accuracy of predictions of count and of detection/non-detection of each taxon, and of aggregate estimates of taxon richness in each sample. We assessed prediction at the level of sample rather than at the sample-unit level because the model allows prediction at that level, and our primary interest is to predict mean response to riffle construction at the site level.

### Methods

For the each environmental variable, we compared the mean of observed values for each sample with the posterior prediction distribution of mean. For the multi-taxon model we compared the mean observed count per sample unit with the posterior prediction of the mean count.

We assessed model fit for environmental variables and taxon counts in three ways: the R^2^ of the relationship between mean of the posterior predicted distribution and observed value; and prediction fidelity, the proportion of samples for which the observed value fell inside 95% of the posterior predicted distribution. For *R^2^*, environmental variables were transformed as they were in the model, and for the multi-taxon model, taxon counts were \[log(x + 1)\]-transformed.

We also assessed accuracy of model predictions for occurrence of each taxon (i.e. detection/non-detection) by calculating detection fidelity, the proportion of posterior predictions which correctly predicted presence or absence.

Finally, we assessed the accuracy of the multi-taxon model's estimates of assemblage level metrics, by calculating the *R^2^* of the linear regression between predicted and observed number of taxa in each sample, both total number of taxa, and the number of Ephemeropotera, Plecoptera and Trichoptera taxa (three groups of sensitive species commonly used as a stream health metric). The posterior prediction distribution of number of taxa in each sample was calculated by summing the predictions of presence (i.e. non-zero counts) of taxa.

```{r}
#| label: tbl-nbinom_me_fit_by_taxon
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Model fit statistics for all taxa in the multi-taxon model.  R squared of the relationship between mean of the predicted posterior distribution and observed count, prediction fidelity (the proportion of observed sample mean that fell within 95% of the posterior predicted distribution for each sample), and detection accuracy (the proportion of occurrences accurately predicted)."

load(paste0(model_fit_dir,"c_draws.rda"))
c_obs <- aggregate(mt_data$c, by = list(samples$sample), FUN = sum)

# percentile of posterior predictive distribution equal to observed value 
# (not used)
ppd_ppn <- c_obs
for(i in 1:mt_data$n_taxa){
for(j in 1:mt_data$n_sample){
    if(c_obs[j, i + 1] == median(c_draws[[i]][,j])){
      ppd_ppn[j,i + 1] <- 0.5
      }else{
      ppd_ppn[j,i + 1] <- ecdf(c_draws[[i]][,j])(c_obs[j, i + 1]) 
        }
}
}
outl <- function(x) { sum(x > 0.975 | x < 0.025)}

oe_stats <- data.frame(taxon = names(c_obs)[-1],
                       r.squ = NA, slope = NA, 
                       mean_ppd_pctl = apply(ppd_ppn[,-1],2,FUN = median), 
                       n_outlier = apply(ppd_ppn[,-1],2,FUN = outl),
                       abs_det_ppn = NA, pre_det_ppn = NA, det_ppn = NA)
for(i in 1:nrow(oe_stats)){
x <- log(c_obs[,i + 1] + 1)
y <- apply(log(c_draws[[i]] + 1),2,FUN = mean)
oe_stats$r.squ[i] <- summary(lm(y ~ x))$adj.r.squared
oe_stats$slope[i] <- coefficients(lm(y ~ x))[2]
abs_det <- pre_det <- det <- 0
n_abs <- n_pre <- 0
for(j in 1:length(c_obs[,i + 1])){
  if(c_obs[j,i+1] == 0){
  abs_det <- abs_det + sum(c_draws[[i]][,j] == 0)
  n_abs <- n_abs + 1
  }else{
  pre_det <- pre_det + sum(c_draws[[i]][,j] > 0)
  n_pre <- n_pre + 1
  }
  det_ppn <- abs_det + pre_det
}
oe_stats$abs_det_ppn[i] <- abs_det/(n_abs * nrow(c_draws[[i]]))
oe_stats$pre_det_ppn[i] <- pre_det/(n_pre * nrow(c_draws[[i]]))
oe_stats$det_ppn[i] <- det_ppn/(prod(dim(c_draws[[i]])))
}
oe_stats$taxoncode <- oe_stats$taxon
oe_stats$taxon <- taxa$taxon[match(oe_stats$taxon,taxa$taxoncode)]
oe_stats$higher_taxon <- taxa$higher_taxon[match(oe_stats$taxoncode,taxa$taxoncode)]
oe_stats$higher_taxon <- higher_taxa$taxon[match(oe_stats$higher_taxon,higher_taxa$higher_taxon)]
ft <- with(oe_stats, 
           data.frame(Taxon = taxon, Classification = higher_taxon, 
                      `R squared` = round(r.squ,2),
                      `Prediction fidelity`= round(1-(n_outlier/53),2),
                      `Detection accuracy` = round(det_ppn,2)))
  ft <- flextable::regulartable(ft)
  ft <- flextable::set_header_labels(ft, values = list(R.squared = "R squared",
                                      Prediction.fidelity = "Prediction fidelity",
                                      Detection.accuracy = "Detection accuracy"))
  ft <- flextable::align(ft, align = "left", part = "all")
  ft <- flextable::valign(ft, valign = "top", part = "all")
  ft <- flextable::font(ft,fontname = "Helvetica", part = "all")
  ft <- flextable::fontsize(ft, size = 10, part = "all")
  ft <- flextable::italic(ft, j = 1, 
                          i = which(taxa$italic[match(oe_stats$taxoncode,taxa$taxoncode)] == 1))
  ft <- flextable::padding(ft, padding.top = 2,  padding.bottom = 2, part = "all")
  ft <- flextable::autofit(ft)
  ft <- flextable::width(ft, width = dim(ft)$widths*6.5 /(flextable_dim(ft)$widths))
ft
```

```{r}
#| label: fig-richness_op
#| echo: false
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 3.5
#| fig-cap: "Predicted mean number of taxa (A. total, B. Ephemeroptera, Plecoptera and Trichoptera, EPT) in the 53 samples plotted against observed number of taxa per sample. Grey lines indicate the 95% confidence intervales of the predicted means, with red lines indicating the 5 samples for which observed total richness fell outside 95% of the posterior prediciton distribution. The solid line indicates the 1:1 relationship, and the dashed line the linear regression of mean predicted as a function of observed (with R2 indicated)."

obs_per_sample <- matrix(ncol = mt_data$n_sample, nrow = mt_data$n_taxa)
for(t in 1:mt_data$n_taxa){
    obs_per_sample[t,] <- aggregate(biota_ct[,t], 
                                     list(sample_no = samples$sample_no), 
                                     FUN = function(y) {sum(y > 0) > 0})$x
  }

sum_gr0 <- function(x) {y <- sum(x > 0); return(y)}
pa_draws <- c_draws
for(i in 1:length(c_draws)) pa_draws[[i]][pa_draws[[i]] > 0] <- 1
tot_rich_draws <- Reduce("+",pa_draws)
outl <- 0
par(mfrow = c(1,2))
par(mar = c(4,4,1,1))
sample_p <- vector("numeric",length = mt_data$n_sample)
for(i in 1:mt_data$n_sample){
  sample_p[i] <- mean(0.01* samples$subsample_perc[samples$sample_no == i])
}
x <- apply(obs_per_sample,2, FUN = sum)
y <- apply(tot_rich_draws,2,FUN = mean)
yqtl <- apply(tot_rich_draws,2,FUN = quantile, probs = c(0.025,0.975))
     # this is a better fit than if FUN = sum with which R2 = 0.64 (0.72))
plot(x, y, cex = 1, axes = FALSE, ylim = c(10,45), xlim = c(10,45),
     xlab = "Observed no. taxa", ylab = "Predicted no. taxa")
for(i in 1:length(x)){
  qtli <- t(yqtl[,i])
  outl <- outl+ as.numeric(x[i] > max(qtli) | x[i] < min(qtli))
  lines(rep(x[i],2), qtli, col = ifelse(x[i] > max(qtli) | x[i] < min(qtli),"red", "gray"))
}
axis(1); axis(2, las = 1); box(bty = 'l')
abline(0,1)
abline(lm(y ~ x), lty = 3)
r21 <- round(summary(lm(y ~ x))$adj.r.squared,2)
title(main = "A.", adj = 0)
title(main = paste0("  R-sq = ", r21), 
      adj = 0, line = -1, font.main = 1, cex.main = 1)

x <- apply(obs_per_sample[substr(colnames(mt_data$c),1,2) %in% c("QE","QP","QT"),],2, FUN = sum)
ept_rich_draws <- Reduce("+",
                         pa_draws[substr(colnames(mt_data$c),1,2) %in% c("QE","QP","QT")])
y <- apply(ept_rich_draws,2,FUN = mean)
     # this is a better fit than if FUN = sum with which R2 = 0.92 (0.92))
yqtl <- apply(ept_rich_draws,2,FUN = quantile, probs = c(0.025,0.975))
     # this is a better fit than if FUN = sum with which R2 = 0.64 (0.72))
plot(x, y, cex = 1, axes = FALSE, ylim = c(0,8), xlim = c(0,8),
     xlab = "Observed no. EPT taxa", ylab = "Predicted no. EPT taxa")
for(i in 1:length(x)){
  qtli <- t(yqtl[,i])
  lines(rep(x[i],2), qtli, col = ifelse(x[i] > max(qtli) | x[i] < min(qtli),"red", "gray"))
}
axis(1); axis(2, las = 1); box(bty = 'l')
abline(0,1)
abline(lm(y ~ x), lty = 3)
r21 <- round(summary(lm(y ~ x))$adj.r.squared,2)
r22 <- round(summary(lm(y ~ x + sample_p))$adj.r.squared,2)
title(main = "B.", adj = 0)
title(main = paste0("  R-sq = ", r21), 
      adj = 0, line = -1, font.main = 1, cex.main = 1)

```

### Results

All environmental variables were well predicted by their respective models: R^2^ \>0.86 for observed: predicted for all models, and observed values falling within 95% of the posterior predicted distribution for \>89% of samples (Table 1).

The counts of all taxa were well predicted by the model. Counts in all samples fell within 95% of the posterior predicted distribution (prediction fidelity = 1, Table 2) for all but 3 taxa, for which one sample fell outside (prediction fidelity = 0.98). Mean *R^2^* of predicted vs observed relationships taxon counts was `r round(mean(oe_stats$r.squ),2)`, with *R^2^* for all but 3 species \>0.7. The model also predicted taxon occurrence well, with a mean detection accuracy of `r round(mean(oe_stats$det_ppn),2)` (minimum `r round(min(oe_stats$det_ppn),2)`, with all but `r sum(oe_stats$det_ppn < 0.8)` taxa \>0.8).

The predictions of occurrence summed to predictions of taxon richness that matched the observed data well (@fig-richness_op). *R^2^* for the relationship between observed total richness and mean predicted total richness was 0.8, with observed richness for `r round(100*(1 -outl/53))`% of samples falling within 95% of the posterior predicted distribution (@fig-richness_op A). The relationship for predicted EPT richness was stronger (@fig-richness_op B).

The accurate prediction of the data by all models provide confidence in inferences of the experimental effects of interest.

## References
