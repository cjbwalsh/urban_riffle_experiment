---
title: "Appendix S3. Methods and code for fitting and assessing the models"
author: "Christopher J Walsh, J Angus Webb, Peter F Breen"
format: docx
editor: visual
editor_options: 
  chunk_output_type: console
bibliography: references.bib
csl: journal-of-applied-ecology.csl
---

```{r}
#| echo: false
#| message: false
#| error: false
#| include: false

######### READ THIS CHUNK BEFORE PROCEEDING ########
# If you want to run the 'eval: false' chunks in this document, you will need to 
# adjust the following directory for keeping large files
model_fit_dir <- 
    "~/uomShare/wergStaff/ChrisW/git-data/urban_riffle_experiment/model_fits/"

## Packages required for evaluated chunks
requiredPackages <- c("osfr","dplyr","flextable","readxl")
lapply(requiredPackages, require, character.only = TRUE)
## Packages required for 'eval: false' chunks: WriteXLS and cmdstanr 
## (See chunk 'sample_model')

## Check if there is a 'data' directory. If not make one
if(!"data" %in% dir()){dir.create("data")}
## While in review, the 3 large data files are in a private OSF repository
## They can be downloaded to the data directory using this view-only link
## https://osf.io/cms84/?view_only=256efadc4a124bcb96c6483226ef3a23
## When the repository is public, the following will allow automatic download
# ## The following checks for large data files, and if absent downloads them 
# ## from the OSF repository to the data directory
# if(!"wq_data_compiled.xlsx" %in% dir("data")){
# wq_files <- osf_retrieve_node("cms84") %>% osf_ls_files()
# osf_download(wq_files, path = "data")
# }
```

The first part of this document details the specifications and code used to estimate the model of taxon abundance in the main paper. The second part assesses the model fit.

### 1. Model specification

The dataset for all models consisted of 3--4 sample units, collectively termed a sample, taken from each of 9 sites (6 experimental in which riffles were constructed and 3 controls) on each of 6 occasions (2 before, B; 2 in the first year after, A1; and 2 5-6 years after riffle construction, A2). Each sample was taken in either autumn (spring = 0) or spring (spring = 1).  The sites spanned an urban gradient represented by (log-transformed and scaled) effective imperviousness I.

We estimated the posterior distributions of parameters in the multi-taxon model of taxon abundances and the models of environmental variables (depth, velocity and $\Phi$, particle size) in the sample units using the Markov chain Monte-Carlo (MCMC) sampler of Stan [@carpenter_etal_2017], calling Stan from R using the library `cmdstanr` [@gabry_cesnovar_2022].

We used weakly informative prior distributions for all parameters, and confirmed that resulting posterior distributions were substantially narrower.  We modelled the environmental variables (transformed as necessary, Table 1) as normal disributions with standard deviation (sd) having a prior normal distribition (mean 0, sd 1). In the multi-taxon model, we modelled count of each taxon in each sample unit as a negative binomial distribution with a dispersion parameter ($\phi$) having a normal prior distribution (mean 1, sd 1).

In all models, we formulated $\beta$ parameters (of fixed effects) as random effects drawn from community-level hyper-distributions with the mean parameters specified as diffuse normal distributions (mean 0, sd 5) and, for the multi-taxon model, the parameters for each species were drawn from a multivariate normal distribution with a covariance matrix that describes the residual associations among species. The hyperprior correlation matrix ($\Omega$) had an LKJ prior with shape 2, and scale with an exponentially distributed prior with rate 1 [@stan_dev_team_2022]. For all models, the random-effect parameters for site ($\theta_{s}$), time ($\theta_{t}$) and sample ($\theta_{s,t}$) were drawn from normal hyper-distributions, with mean 0 and sd with a normal prior distribution (mean 0, sd 1). 

For the multi-taxon model, we drew inference from 5,000 posterior samples taken from 4 unthinned chains, discarding the first 1,000 samples of each chain. This number of samples was sufficient to ensure bulk and tail effective sample sizes of at least 100 per chain for all parameters. We diagnosed convergence by visually inspecting the MCMC chains for adequate mixing and stationarity, and ensured that the diagnostic tests for zero-divergent transitions, Gelman-Rubin statistic ($\hat{R}$) \< 1.1, and zero cases of saturated tree-depth were satisfied. The Bayesian Fraction of Missing Information (mean 0.299) was marginally lower than the nominal threshold of 0.3.

The environmental variable models remain a work in progress. Although the inferences made from them appear sound, the models did not, in their current parameterization, satisfy Stan's diagnostic criteria (Table 1). The velocity models in particular have low BFMI, resulting in low effective sample size. The phi models are ok, except for a small number (\<0.01%) of divergences (this is probably satisfactory). *Any suggestions?* ($\hat{R}$ and zero tree-depth criteria were met by all)

```{r}
#| echo: false
#| label: tbl-univar_diagnostics
#| tbl-cap: "Temporary table showing summary diagnostics for environmental variable models, pending their improvement."

#load univar diagnostics table 
load("small_data/env_var_model_summaries.rda")
univar_diagnostics <- univar_diagnostics[univar_diagnostics$model %in% 
                        c("depth_m_var","depth_m_mean","vel_m_s_var",
                          "vel_m_s_mean","min_phi","med_phi"),
                        c("model","divergences","min_bfmi","min_ess_bulk")]
univar_diagnostics$min_bfmi <- round(univar_diagnostics$min_bfmi,3)
univar_diagnostics$min_ess_bulk <- round(univar_diagnostics$min_ess_bulk)
flextable::flextable(univar_diagnostics)
```

The multi-taxon model `nbinom_me_rand_sa_si_t_fixedmatrix-baci.stan` is reproduced below, with annotations defining variables and parameters, and explaining model components. Below that is the code used to load the data, run, check and evaluate the model, and produce output objects used to produce figures in the manuscript. Note that the multi-taxon model took 3.6 h to run on a 2.6-GHz system on 4 parallel cores, and compilation of the parameter draws required \~50 Gb RAM.

*Similar detail for environmental variable models? (Currently residing in univars_trial.R)*

<!--# Some final, time consuming, tweaking of the model priors.  sd_lam N(0,1), phi N(0,1) ran ok, but produced BFMI 0.273, 0.289, 0.290, 0.309 with min bulk_ess just over 400 with 2000 + 6000 iters.  sd_lam N(0.5,1), phi N(1,1), saved as fit_riffle_baci_a, was only marginally better: BFMI 0.32,0.28,0.31,0.29. with min bulk_ess 393 with 2000 + 6000 iters; sd_lam N(1,1), phi N(1,1), saved as fit_riffle_baci_b, better, I think, allowing for fewer iterations: BFMI 0.32, 0.29, 0.37, 0.24, min bulk_ess 62 with 2000 + 1000 iters; phi N(1,1), and with eps term removed completely, saved as fit_riffle_baci_c was ~2/3 quicker, but substantially worse: BFMI 0.15, 0.16, 0.14, 0.21; min bulk_ESS 48 with 2000 + 1000 iters, So decided on original eps model, with sd_lam N(1,1), phi N(1,1), 3500 burn-in, 6500 samples ...but no such luck BFMI 0.29,0.30,0.32, 0.28, and min ess_bulk 345, , saved as fit_riffle_baci_d, min ess_tail 360 - the difficult parameter is sigma_t mean 0.6 (0.4-0.79)...so, sigma_t exp(2.5)...which didn't help at all...Also tried sigma_t exp(0.2), with very little change.  So, I tried sd_lam N(1,1), phi N(1,1) sigma_t exp(1) with 2500 + 6500 with random seed 9430569 (all of the above were with 9430570), BFMI 0.314, 0.300, 0.265, 0.297, but only min bulk ESS 328. I also tried the sd_lam N(1,1), phi N(1,1) version with adapt_delta 0.9 and 0.95 - neither made any difference to the BFMI being just too low...-->

#### The multi-taxon model: Stan code

```{r}
#| echo: true
#| eval: false

data {
  int<lower=0> n_obs;         // Number of observations (sample-units, s-u)
  int<lower=1> n_taxa;        // Number of taxa
  int<lower=1> n_site;        // Number of sites
  int<lower=1> n_sample;      // Number of samples
  int<lower=1> n_pred;        // Number of predictor variables
  int<lower=1> n_t;           // Number of sampling occasions
  matrix[n_obs,n_pred] u;     // group predictors (model matrix) 
  array[n_obs,n_taxa] int c;  // Count of each taxon in each subsample
  array[n_obs,n_taxa] real s; // Subsample proportion for each s-u
  array[n_obs] int site_no;   // Site number
  array[n_obs] int samp_no;   // Sample number (vectorised [t_no, site_no])
  array[n_obs] int t_no;      // Sampling occasion number
}
parameters {
  vector[n_pred] mu_gamma;         //means of beta parameter hyperdistributions          
  matrix[n_pred,n_taxa] gamma;        // beta parameters of fixed effects in u
  matrix[n_site,n_taxa] a_s_raw;      // raw coefficient of random site effect
  matrix[n_t,n_taxa] a_t_raw;         // raw oefficient of time effect 
  matrix[n_sample,n_taxa] a_st_raw;   // raw coefficient of random sample effect 
                                      //(1 sample per site_no per t_no)
  // see reparameterizations below for explanationof these raw coefficients
  vector<lower=0>[n_taxa] sigma_s; //rsd of hyperdistribution of a_sis among taxa
  vector<lower=0>[n_taxa] sigma_t; //sd of hyperdistribution of a_ts among taxa
  vector<lower=0>[n_taxa] sigma_st;//sd of hyperdistribution of a_sas among taxa
  vector<lower=0>[n_taxa] phi;     //dispersion parameter for neg-binomial distn
  corr_matrix[n_pred] Omega;       // Hyperprior correlation matrix among taxa
  vector<lower=0>[n_pred] tau;     // Scale for correlation matrix
}
transformed parameters {
  matrix[n_obs,n_taxa] log_lambda;  // Log total count
  matrix[n_site,n_taxa] a_s;        // coefficient of random site effect
  matrix[n_t,n_taxa] a_t;           // Coefficient of random time effect 
  matrix[n_sample,n_taxa] a_st;     // coefficient of random sample effect
                         // (sample = 3-4 s-us from each site on each occasion)
  for(j in 1:n_taxa){
  a_s[,j] =  sigma_s[j] * a_s_raw[,j];  
  a_t[,j] =  sigma_t[j] * a_t_raw[,j];  
  a_st[,j] =  sigma_st[j] * a_st_raw[,j];  
  }
// with (e.g.) a_s_raw ~ std_normal(), this implies a_s ~ normal(0, sigma_s)
// See https://mc-stan.org/docs/stan-users-guide/reparameterization.html

  for(i in 1:n_obs){
     for(j in 1:n_taxa){
       //The linear model
      log_lambda[i,j] = a_s[site_no[i],j] +  a_t[t_no[i],j] +  
                       a_st[samp_no[i],j] +  u[i,] * gamma[,j]; 
      }
      }
}

model {
  // Priors
   mu_gamma ~ normal(0,5);
   to_vector(a_s_raw) ~ std_normal();
   to_vector(a_t_raw) ~ std_normal();
   to_vector(a_st_raw) ~ std_normal();
   sigma_s ~ normal(0,1);
   sigma_t ~ normal(0,1);
   sigma_st ~ normal(0,1);
   phi ~ normal(1,1);
   tau ~ exponential(1);
   Omega ~ lkj_corr( 2 );  
   
   // estimation of correlated beta parameters (assembled in matrix gamma)
   for(i in 1:n_taxa){
   target += multi_normal_prec_lpdf(gamma[,i] | mu_gamma, quad_form_diag(Omega, 
                                                                         tau) );
     }
  // Likelihood
  for (i in 1 : n_obs) {
    for(j in 1:n_taxa){
    target += neg_binomial_2_log_lpmf(c[i,j] | log_lambda[i,j] + log(s[i,j]), 
                                      phi[j]);
  // This parameterization adds the marginal log-binomial-probability 
  // resulting from subsampling error to the marginal negative-binomial 
  // probability of the linear model.  It is equivalent to a (50 times) slower 
  // parameterization modelling the marginal binomial and negative-binomial
  // probabilities separately, by looping through all feasible total counts
  // given a each count and subsample proportion.
   }
  }
}

generated quantities {
  // log-likelihood only used for model comparisons during model development.
  // The most complex model considered has been used,
  // so model comparisons not reported
  array[n_obs,n_taxa] real log_lik;
 for (i in 1 : n_obs) {
   for(j in 1 : n_taxa){
   log_lik[i,j] = neg_binomial_2_log_lpmf(c[i,j] | log_lambda[i,j] +
                    log(s[i,j]), phi[j]);
 }
 }
 }

```

#### Assembling data and model sampling: R code

```{r}
#| echo: true
#| message: false
#| error: false

source("misc_functions.R") # for ct function
dat_file <- "data/urban_riffle_experiment_data_for_model.xlsx"
sites <- data.frame(readxl::read_excel(dat_file, sheet = "sites"), 
                    stringsAsFactors = FALSE)
samples <- data.frame(readxl::read_excel(dat_file, sheet = "samples"), 
                      stringsAsFactors = FALSE)
biota <- data.frame(readxl::read_excel(dat_file, sheet = "biota"), 
                    stringsAsFactors = FALSE)
taxa <- data.frame(readxl::read_excel(dat_file, sheet = "taxa"), 
                   stringsAsFactors = FALSE)
higher_taxa <- data.frame(readxl::read_excel(dat_file, sheet = "higher_taxa"), 
                   stringsAsFactors = FALSE)

samples$seg <- substr(samples$old_samplecode,nchar(samples$old_samplecode)-1,
                      nchar(samples$old_samplecode)-1)
# The dataset contains samples from the segments upstream and downstream of the 
# riffle (putative or real) in each site for trip 1-4 (out of 6).  Given the 
# small effects in the 'riffle' segments (M), theu U and L segments were not 
# included in the analysis.
samples <- samples[samples$seg == "M",]
# Reduce biota table to match reduced samples table
biota <- biota[biota$smpcode %in% samples$smpcode,]
# Convert long-form biota table into a wide taxon-by-sample table of counts 
# in subsamples
biota_ct <- as.data.frame(ct(biota$smpcode, biota$shortcode, biota$count))
biota_ct <- biota_ct[match(samples$smpcode,row.names(biota_ct)),]
# Create a table of the same dimensions as biota_ct, with the subsample proportion
# for each observation (for coarsepick specimens, subsample ppn = 1)
ss_ct <- biota_ct
for(i in 1:nrow(samples)){
  ss_ct[i,] <- samples$subsample_perc[i]/100
}
for(i in which(biota$coarsepick == 1)){
  ss_ct[row.names(ss_ct) == biota$smpcode[i], biota$shortcode[i]] <- 1
}

# Assemble random predictors (site_no, sample_no, t)
sites <- sites[order(sites$exp_treatment,sites$ai),]
sites$site_no <- 1:nrow(sites)
samples$site_no <- sites$site_no[match(samples$sitecode,sites$sitecode)]
samples$sample <- substr(samples$old_samplecode,1,nchar(samples$old_samplecode)-1)
sample_nos <- data.frame(sample = unique(samples$sample))
sample_nos$sample_no <- 1:nrow(sample_nos)
samples$sample_no <- sample_nos$sample_no[match(samples$sample, sample_nos$sample)]
samples$t_no <- as.numeric(substr(samples$old_samplecode, 1,1))

# Assemble fixed predictors (a1,a2, ci, ba1ci, ba2ci, i, ba1cii, ba2cii, spring) into a matrix, u
samples$ba <- as.numeric(as.numeric(substr(samples$old_samplecode,1,1)) %in% c(3,4)) 
samples$ba[as.numeric(as.numeric(substr(samples$old_samplecode,1,1))) %in% c(5,6)] <- 2
samples$ba <- factor(samples$ba)
# a1 and a2 are the two after periods treated as categories with b as a reference
samples$ci <- as.numeric(sites$exp_treatment[match(samples$sitecode,sites$sitecode)] == "riffle") 
# 0 = control, 1 = riffle
samples$ai <- sites$ai[match(samples$sitecode, sites$sitecode)]
i_scaled <- scale(log10(samples$ai*100 + 0.1))
samples$i <- as.vector(i_scaled)
samples$spring <- as.integer(substr(samples$old_samplecode,1,1) %in% c(1,3,5))
u <- model.matrix(~ ba + ci + ba:ci + i + ba:ci:i + spring, data = samples)

# Data list for Stan
sdata <- list(n_obs = nrow(biota_ct),
              n_taxa = ncol(biota_ct),
              n_site = nrow(sites),
              n_sample = nrow(sample_nos),
              n_pred = ncol(u),
              n_t = max(samples$t),
              site_no = samples$site_no,
              samp_no = samples$sample_no,
              t_no = samples$t_no,
              u = u,
              c = as.matrix(biota_ct),
              s = as.matrix(ss_ct)
)
```

```{r}
#| label: sample_model
#| echo: true
#| message: false
#| error: false
#| eval: false

# load and check cmdstanr package
library(cmdstanr) # see https://mc-stan.org/cmdstanr/articles/cmdstanr.html
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
# Set random seed to ensure reproducible results
rand_seed = 9430570 

# Check model is up-to-date: if not, compile.
mod <- cmdstan_model("nbinom_me_rand_sa_si_t_fixedmatrix_baci.stan", pedantic = TRUE) 

ni <- 5000; nt <- 4; nb <- 1000; nc <- 4
stanfit_i <- mod$sample(data = sdata,
                        seed = rand_seed, chains = nc,
                        parallel_chains = nc, iter_warmup = nb,
                        iter_sampling = ni - nb, refresh = 100)
# 5000 iterations took ~2 h
# #  save csv files rather than the model object to use less RAM
stanfit_i$save_output_files(dir = model_fit_dir, basename = "fit_riffle_baci_mt", 
                            timestamp = FALSE, random = FALSE)
stanfit_i$sampler_diagnostics()
saveRDS(stanfit_i, file = paste0(model_fit_dir,"fit_riffle_baci_mt.rds"))
stanfit_i$diagnostic_summary()
# EBFMI 0.41, 0.53, 0.49, 0.48 zero divergences, zero max tree depth reached.
# # The above three steps required < 500 Mb RAM
summ <- stanfit_i$summary() # took an additional 0.5 h and needed >40 Gb RAM
min(summ$ess_bulk,na.rm=TRUE) # 569
min(summ$ess_tail,na.rm=TRUE) # 943
max(summ$rhat,na.rm=TRUE)  # 1.013
# # all diagnostic_summary diagnostics were satisfied

mod_draws <- as.data.frame(stanfit_i$draws(format = "df", variables = c("a_s","a_t","a_st","gamma","phi")))
save(mod_draws, file = paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))
```

Extract prediction of mean abundance for each taxon in each sample (for assessment of model fit).

```{r}
#| label: predy_summary
#| echo: true
#| eval: false

# predx is the unique set of predictors to permit prediction the mean abundance
#  of each taxa in each of the samples of the study (for assessing model fit):
#  a data.frame with 14 predictors (columns) and 53 combinations of predictor 
#  values equivalent to the dataset used to derive the model (rows).
# predy_draws is a list of 113 elements (one for each taxon; name of each element a taxoncode)
# each element is a data.frame with 53 columns (mathching predx rows) and 32000
# rows: the posterior distribution of the predicted mean abundance for each predx value.

predx <- unique(data.frame(site_no = samples$site_no,
                           sample_no = samples$sample_no,
                           t = samples$t,u))
predy_draws <- list()
system.time({
for(i in 1:sdata$n_taxa){
  drawsi <- mod_draws[grep(paste0(",",i,"]"), names(mod_draws))]
  predy_draws[[i]] <-
    drawsi[grep("a_si",names(drawsi))][match(predx$site_no, 1:sdata$n_site)] +
    drawsi[grep("a_sa",names(drawsi))][match(predx$sample_no, 1:sdata$n_sample)] +
    drawsi[grep("a_t",names(drawsi))][match(predx$t, 1:sdata$n_t)] +
      drawsi[,paste0("gamma[1,",i,"]")] %*% t(predx$X.Intercept.) +
       drawsi[,paste0("gamma[2,",i,"]")] %*% t(predx$ba1) +
       drawsi[,paste0("gamma[3,",i,"]")] %*% t(predx$ba2) +
       drawsi[,paste0("gamma[4,",i,"]")] %*% t(predx$ci) +
       drawsi[,paste0("gamma[5,",i,"]")] %*% t(predx$i) + 
       drawsi[,paste0("gamma[6,",i,"]")] %*% t(predx$spring) +
       drawsi[,paste0("gamma[7,",i,"]")] %*% t(predx$ba1.ci) +
       drawsi[,paste0("gamma[8,",i,"]")] %*% t(predx$ba2.ci) +
       drawsi[,paste0("gamma[9,",i,"]")] %*% t(predx$ba0.ci.i) + 
       drawsi[,paste0("gamma[10,",i,"]")] %*% t(predx$ba1.ci.i) +
       drawsi[,paste0("gamma[11,",i,"]")] %*% t(predx$ba2.ci.i) 
}
})  # 1 min
names(predy_draws) <- colnames(sdata$c)
save(predy_draws, file = paste0(model_fit_dir,"fit_riffle_baci_predy_draws.rda"))

params <- c("b_ba1", "b_ba2", "b_ci","b_i","b_spring","b_ba1ci","b_ba2ci","b_ba0cii","b_ba1cii", "b_ba2cii")
df_empty <- data.frame(shortcode = NA, mean = NA, lo95 = NA, lo90 = NA, median = NA, hi90 = NA, hi95 = NA)[0,]
predy_draws <- get(load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda")))
param_summs <- list()
for(i in 1:length(params)){
  drawsi <- mod_draws[substr(names(predy_draws),1,ifelse(i < 9, 7, 8)) == paste0("gamma[", i + 1) & 
                          grepl("gamma", names(mod_draws))]
  qlsi <- as.data.frame(t(apply(drawsi,2, FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- apply(drawsi,2, FUN = mean)
  param_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(param_summs) <- params
WriteXLS::WriteXLS(param_summs, "small_data/param_summs.xlsx")
```

Extract posterior distribution of mean abundance for each taxon in samples across the gradient of imperviousness for all combinations of *ba* = 0, 1 or 2; *ci* = 0 or 1; *I* = minimum and maximum values in dataset (=4% and 32% EI); spring = 0 (i.e. autumn), omitting random sample, site and t errors (For counterfactual plot demonstrating effect of riffle emplacement under different levels of urban impact), and the primary differences of interest in the BACI design:

1.  (control minus impact before \[B\]) - (control minus impact in first year after \[A1\]) for low (minimum) *I*

2.  (control minus impact before \[B\]) - (control minus impact 5-6 y after \[A2\]) for low *I*

3.  (control minus impact before \[B\]) - (control minus impact in first year after \[A1\]) for high *I*

4.  (control minus impact before \[B\]) - (control minus impact 5-6 y after \[A2\]) for high *I*

```{r}
#| label: pred_cf
#| echo: true
#| eval: false

# load draws of parameters from model (object mod_draws calculated above)
load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))

# predx_cf is the table of scenario predictor variables for counterfactual plots/analysis
# predy_cf is a list with 113 elements, one for each taxon (each element has a taxoncode as a name)
# each element is a table of posterior distributions (32000 draws in rows) for the 60 scenarios (in columns)
predx_cf <- expand.grid(intercept = 1, ba = factor(c(0,1,2)), ci = c(0,1), 
                        i = seq(min(u[,5]),max(u[,5]),length=10), spring = 0)
predx_cf <- data.frame(model.matrix(~ ba + ci + ba:ci + i + ba:ci:i + spring, 
                                    data = predx_cf))
predx_cf$ai <- 10^(predx_cf$i * attr(i_scaled, 'scaled:scale') + 
                attr(i_scaled, 'scaled:center')) - 0.1
predy_cf <- delta_baci1_low <- delta_baci2_low <- delta_baci1_hi <- delta_baci2_hi <- list()

# delta_posts takes 12 of the scenarios and calculates four differences used as evidence of riffle effect.
# it is a list of four lists (one for each difference). Each difference has 113 elements (taxa, as above)
# and each element is a vector length 32000 of the posterior distribution of the diffence for each taxon.
  
# The 12 scenarios for calculating differences  
combos <- list(control_hii = which(predx_cf$ci == 0 & predx_cf$i == max(predx_cf$i)),
               impact_hii = which(predx_cf$ci == 1 & predx_cf$i == max(predx_cf$i)),
               control_lowi = which(predx_cf$ci == 0 & predx_cf$i == min(predx_cf$i)),
               impact_lowi = which(predx_cf$ci == 1 & predx_cf$i == min(predx_cf$i)))

system.time({
for(i in 1:sdata$n_taxa){
  drawsi <- mod_draws[grep(paste0(",",i,"]"), names(mod_draws))]
  predy_cf[[i]] <-
       drawsi[,paste0("gamma[1,",i,"]")] %*% t(predx_cf$X.Intercept.) +
       drawsi[,paste0("gamma[2,",i,"]")] %*% t(predx_cf$ba1) +
       drawsi[,paste0("gamma[3,",i,"]")] %*% t(predx_cf$ba2) +
       drawsi[,paste0("gamma[4,",i,"]")] %*% t(predx_cf$ci) +
       drawsi[,paste0("gamma[5,",i,"]")] %*% t(predx_cf$i) + 
       drawsi[,paste0("gamma[6,",i,"]")] %*% t(predx_cf$spring) +
       drawsi[,paste0("gamma[7,",i,"]")] %*% t(predx_cf$ba1.ci) +
       drawsi[,paste0("gamma[8,",i,"]")] %*% t(predx_cf$ba2.ci) +
       drawsi[,paste0("gamma[9,",i,"]")] %*% t(predx_cf$ba0.ci.i) + 
       drawsi[,paste0("gamma[10,",i,"]")] %*% t(predx_cf$ba1.ci.i) +
       drawsi[,paste0("gamma[11,",i,"]")] %*% t(predx_cf$ba2.ci.i) 
}
names(predy_cf) <- names(biota_ct)
 
for(i in 1:sdata$n_taxa){
delta_baci1_low[[i]] <- predy_cf[[i]][,combos$control_lowi[1]] - predy_cf[[i]][,combos$impact_lowi[1]] -
                    (predy_cf[[i]][,combos$control_lowi[2]] - predy_cf[[i]][,combos$impact_lowi[2]])
delta_baci2_low[[i]] <- predy_cf[[i]][,combos$control_lowi[1]] - predy_cf[[i]][,combos$impact_lowi[1]] -
                    (predy_cf[[i]][,combos$control_lowi[3]] - predy_cf[[i]][,combos$impact_lowi[3]])
delta_baci1_hi[[i]] <- predy_cf[[i]][,combos$control_hii[1]] - predy_cf[[i]][,combos$impact_hii[1]] -
                    (predy_cf[[i]][,combos$control_hii[2]] - predy_cf[[i]][,combos$impact_hii[2]])
delta_baci2_hi[[i]] <- predy_cf[[i]][,combos$control_hii[1]] - predy_cf[[i]][,combos$impact_hii[1]] -
                    (predy_cf[[i]][,combos$control_hii[3]] - predy_cf[[i]][,combos$impact_hii[3]])
}
})  # 5 s
save(predy_cf, delta_posts, 
     file = paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

# summary table of precentiles for all species for 12 scenarios used for 
# inference of baci effect
taxon_abun_cf_summs <- list()
for(i in unlist(combos)){
  list_index <- which(unlist(combos) == i)
  tabi <- data.frame(taxoncode = names(predy_cf), 
                     mean = NA, "lo95" = NA, "lo90"= NA, "lo75" = NA,
                    "median" = NA,"hi75" = NA,"hi90" = NA,"hi95" = NA)
  for(j in 1:length(predy_cf)){
    tabi$mean[j] <- mean(predy_cf[[j]][,i])
    tabi[j,-(1:2)] <- quantile(predy_cf[[j]][,i], 
                             probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))
  }
  taxon_abun_cf_summs[[list_index]] <- tabi
}
names(taxon_abun_cf_summs) <- names(unlist(combos))
WriteXLS::WriteXLS(taxon_abun_cf_summs, "small_data/taxon_abun_cf_summs.xlsx")

delta_posts <- list(delta_a1_4ei = delta_baci1_low, 
                    delta_a2_4ei = delta_baci2_low, 
                    delta_a1_32ei = delta_baci1_hi, 
                    delta_a2_32ei = delta_baci2_hi)

diff_summs <- list()
for(i in 1:length(delta_posts)){
  qlsi <- as.data.frame(do.call(rbind,lapply(delta_posts[[i]],FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- unlist(lapply(delta_posts[[i]],FUN = mean))
  diff_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(diff_summs) <- names(delta_posts)
WriteXLS::WriteXLS(diff_summs, "small_data/diff_summs.xlsx")
```

```{r}
#| label: calc_assemb_stats
#| echo: false
#| eval: false

# load draws of parameters from model (calculated above)
load(paste0(model_fit_dir,"fit_riffle_baci_draws.rda"))

phi_draws <- mod_draws[,grep("phi",names(mod_draws))]
p_cf_mat <- list()
n_cf_mat <- list()

# load taxon abundance predictions for 60 counter-factual scenarios from above
load(paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))
# And use them to calculate assemblage statistics

# system.time({
for(t in 1:ncol(biota_ct)){
p_cf_mat[[t]] <- predy_cf[[t]]
n_cf_mat[[t]] <- exp(predy_cf[[t]])
for(i in 1:ncol(p_cf_mat[[t]]))
  # Probability of occurrence in 1 sample unit
p_cf_mat[[t]][,i] <- 1 - pnbinom(0,mu = exp(predy_cf[[t]][,i]),
                                 size = phi_draws[t][,1])
  # Probability of occurrence in 4 sample units
p_cf_mat[[t]] <- 1 - (1 - p_cf_mat[[t]])^4
  # back-transformed abundance per 4 samples
}
# }) # ~15 s
names(p_cf_mat) <- colnames(biota_ct)
tot_rich_cf_mat <- Reduce('+', p_cf_mat)
# see https://stackoverflow.com/questions/11641701/sum-a-list-of-matrices
ept_rich_cf_mat <- Reduce('+', p_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QE","QP","QT")])
do_rich_cf_mat <- Reduce('+', p_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QD","LO")])

tot_n_cf_mat <- Reduce('+', n_cf_mat)
ept_n_cf_mat <- Reduce('+', n_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QE","QP","QT")])
do_n_cf_mat <- Reduce('+', n_cf_mat[substr(names(p_cf_mat),1,2) %in% c("QD","LO")])

library(vegan)

# Shannon's H' requires proportional abundances
relab_cf_mat <- n_cf_mat
tot_abund_cf_mat <- Reduce('+', n_cf_mat)
for(i in 1:length(n_cf_mat)){
relab_cf_mat[[i]] <- relab_cf_mat[[i]] / tot_abund_cf_mat
}

H_mat <- relab_cf_mat[[1]]
for(i in 1:nrow(H_mat)){
H_mat[i,] <- diversity(sapply(relab_cf_mat,function(x, n) x[n,],i))
}

# Pielou's Evenness
evenness_cf_mat <- H_mat/log(tot_rich_cf_mat)

# Reduce set to family-presence absence for SIGNAL calculation
biotic_indices<- 
  read.csv("small_data/biotic_indices.csv")
signal <- biotic_indices[!is.na(biotic_indices$SIGNALWoV2003),
                         c("shortcode","taxon","SIGNALWoV2003")]
signal <- signal[signal$shortcode %in%
                             c("LO",substr(names(biota_ct),1,4)),]
signal <- signal[order(signal$shortcode),]
signal_mat <- list()
for(i in 1:nrow(signal)){
  ss <- ifelse(signal$shortcode[i] == "LO",
               which(substr(names(p_cf_mat),1,2) == "LO"),
               which(substr(names(p_cf_mat),1,4) %in% signal$shortcode[i]))
  signal_mat[[i]] <-
    Reduce(function(x) 1-(1-x)^length(ss), p_cf_mat[ss])
  signal_mat[[i]] <- matrix(unlist(Map(function(x) rbinom(1,1,x),
                            signal_mat[[i]])),ncol = ncol(p_cf_mat[[1]]))
  signal_mat[[i]][signal_mat[[i]] > 0] <-
    signal_mat[[i]][signal_mat[[i]] > 0]* signal$SIGNALWoV2003[i]
}
signal_sum_cf_mat <- Reduce('+', signal_mat)
signal_len_cf_mat <- Reduce('+', lapply(signal_mat, function(x)
                      replace(x, x > 0, 1)))
signal_cf_mat <- signal_sum_cf_mat/signal_len_cf_mat

baci_diffs <- function(mat){
  data.frame(delta_baci1_low = 
               mat[,combos$control_lowi[1]] - mat[,combos$impact_lowi[1]] -
                    (mat[,combos$control_lowi[2]] - mat[,combos$impact_lowi[2]]),
             delta_baci2_low = 
               mat[,combos$control_lowi[1]] - mat[,combos$impact_lowi[1]] -
                    (mat[,combos$control_lowi[3]] - mat[,combos$impact_lowi[3]]),
             delta_baci1_hi =
               mat[,combos$control_hii[1]] - mat[,combos$impact_hii[1]] -
                    (mat[,combos$control_hii[2]] - mat[,combos$impact_hii[2]]),
             delta_baci2_hi = mat[,combos$control_hii[1]] - mat[,combos$impact_hii[1]] -
                    (mat[,combos$control_hii[3]] - mat[,combos$impact_hii[3]]))
}

assemb_stats <- list(tot_rich = 
                       data.frame(mean =apply(tot_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(tot_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     shannon_h = 
                       data.frame(mean =apply(H_mat,2, 
                                              FUN = mean),
                                  t(apply(H_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     evenness = 
                       data.frame(mean =apply(evenness_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(evenness_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     ept_rich = 
                       data.frame(mean =apply(ept_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(ept_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     do_rich = 
                       data.frame(mean = apply(do_rich_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(do_rich_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     signal = 
                       data.frame(mean =apply(signal_cf_mat,2, 
                                              FUN = mean, na.rm = TRUE),
                                  t(apply(signal_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975), 
                                          na.rm = TRUE))),
                     tot_n = 
                       data.frame(mean =apply(tot_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(tot_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     ept_n = 
                       data.frame(mean =apply(ept_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(ept_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975)))),
                     do_n = 
                       data.frame(mean =apply(do_n_cf_mat,2, 
                                              FUN = mean),
                                  t(apply(do_n_cf_mat,2, 
                                          FUN = quantile, 
                                          probs = c(0.025, 0.975))))
                     )
WriteXLS::WriteXLS(assemb_stats, "small_data/assemb_stat_summs.xlsx")

assemb_stat_diffs <- list(signal = baci_diffs(signal_cf_mat),
                          evenness = baci_diffs(evenness_cf_mat),
                          H = baci_diffs(H_mat),
                          tot_rich = baci_diffs(tot_rich_cf_mat),
                          ept_rich = baci_diffs(ept_rich_cf_mat),
                          do_rich = baci_diffs(do_rich_cf_mat),
                          tot_n = baci_diffs(tot_n_cf_mat),
                          ept_n = baci_diffs(ept_n_cf_mat),
                          do_n = baci_diffs(do_n_cf_mat))
save(assemb_stat_diffs, file =paste0(model_fit_dir,"assemb_stat_diffs.rda"))

assemb_stat_diffs <-  assemb_stat_diffs[match(c("tot_rich","ept_rich","do_rich",
                                                "signal","tot_n","ept_n","do_n","H","evenness"),
                                              names(assemb_stat_diffs))]
for(i in 1:length(assemb_stat_diffs)){
  drawsi <- assemb_stat_diffs[[i]]
  qlsi <- as.data.frame(t(apply(drawsi,2, FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- apply(drawsi,2, FUN = mean)
  if(i == 1){
  assemb_stat_diff_summs <- data.frame(stat = names(assemb_stat_diffs)[i],
                                       diff = row.names(qlsi), mean = meani, qlsi)
             }else{
  assemb_stat_diff_summs <- rbind(assemb_stat_diff_summs,
                                   data.frame(stat = names(assemb_stat_diffs)[i],
                                               diff = row.names(qlsi), 
                                              mean = meani, qlsi))
                    }
}
WriteXLS::WriteXLS(assemb_stat_diff_summs, "small_data/assemb_stat_diff_summs.xlsx")

# Extract mean abundances in the 12 main scenarios for the top 10 taxa in each scenario
# (For table 1 in the manuscript)
relabunds <- data.frame(scenario = names(unlist(combos)),
                        matrix(nrow = length(unlist(combos)),
                               ncol = length(relab_cf_mat)))
names(relabunds)[-1] <- colnames(sdata$c)
for(i in 1:length(relab_cf_mat)){
  relabunds[,i + 1] <- apply(relab_cf_mat[[i]][,unlist(combos)],2,FUN = mean)
}
top10_propns <- data.frame(scenario = relabunds$scenario, propn = NA)
top10s <- list()
for(i in 1:nrow(relabunds)){
  rai <- t(relabunds[i,-1])
  top10s[[i]] <- row.names(rai)[order(rai, decreasing =  TRUE)[1:10]]
  top10_propns[i,2] <- sum(rai[order(rai, decreasing =  TRUE)[1:10]])
}
tops <- data.frame(taxoncode = c(unique(unlist(top10s[])),NA),
                   Taxon = c(taxa$taxon[match(unique(unlist(top10s[])), 
                                                       taxa$taxoncode)],"% of all taxa"),
                   High.I_Control_B = NA, High.I_Control_A1 = NA, High.I_Control_A2 = NA, 
                   High.I_Impact_B = NA, High.I_Impact_A1 = NA, High.I_Impact_A2 = NA, 
                   Low.I_Control_B = NA, Low.I_Control_A1 = NA, Low.I_Control_A2 = NA, 
                   Low.I_Impact_B = NA, Low.I_Impact_A1 = NA, Low.I_Impact_A2 = NA)
for(i in 1:(nrow(tops)-1)){
  tops[i,-(1:2)] <- round(apply(n_cf_mat[[which(colnames(sdata$c) == tops$taxoncode[i])]][,unlist(combos)],
                          2,FUN = mean))
}
tops[nrow(tops),-(1:2)] <- round(top10_propns$propn*100)
write.csv(tops,"small_data/top10taxa.csv",row.names = FALSE)
```

### 2. Assessment of model fit

We assessed the predictive performance of our model by comparing model predictions of abundance to observed abundance at each site including the random site, stream and time effects.

#### Methods

We quantified model accuracy and bias first by calculating the *R^2^* and slope of the linear regression between predicted and observed log-mean abundance \[log(x + 1)\] of each taxon in each sample (count in each sample unit estimated as count/subsample fraction). We assessed prediction at the level of sample rather than at the sample-unit level because the model allows prediction at that level, and our primary interest is to predict mean response to riffle construction at the site level.

We also assessed accuracy of model predictions for occurrence of each taxon (rather than abundance) by assessing the area under the operator curve (AUC) for logistic regressions between predicted probability of occurrence and observed presence or absence in each sample, where predicted probability of occurrence in a sample,

$$
p\_s = 1 - \Pi(1 - p\_{su}_i)
$$ {#eq-s3_ps}

where $p\_su_i$ is the probability of occurrence in the *i*th sample unit comprising the sample, calculated as 1 - negative-binomial probabliity of zero, given predicted $\mu$ and $\phi$.

Finally, we assessed the accuracy of the multi-taxon model's estimates of assemblage level metrics, by calculating the *R^2^* and slope of the linear regression between predicted and observed number of taxa in each sample, both total number of taxa, and the number of Ephemeropotera, Plecoptera and Trichoptera taxa (three groups of sensitive species commonly used as a stream health metric). Predicted number of taxa was estimated as the sum of probabilities of occurrence for all taxa. Because observed taxon richness is likely to be affected by subsample size, we interpreted the relationship between predicted and observed numbers of taxa accounting for mean subsample proportion in the subsample units making up each sample. We also calculated *R^2^* of the predicted number of taxa as a function of observed number of taxa + mean subsample proportion.

### Results

The abundances of all taxa (estimated as the number counted divided by the subsample fraction) were well predicted by the model. The observed and predicted abundances of all taxa were correlated with R \> 0.75 (@fig-nbinom_me_fit_by_taxon A). Abundance predictions of 42 prevalent and abundant taxa, including all but one of those for which an effect of the experimental riffles was inferred, showed little bias (regression slopes between 0.8 and 1.1), while abundance predictions for taxa with low prevalence tended to be underestimated (slopes \< 0.8, @fig-nbinom_me_fit_by_taxon B). Such underestimation is to be expected for taxa with many zero or low abundances.

The model also predicted occurrence of all taxa with high certainty (all AUC values of the 111 taxa absent from at least one sample \> 0.9, @fig-nbinom_pa_stats). The probabilities of occurrence of all taxa summed to accurate estimates of taxon richness in the 56 samples (@fig-richness_op). The raw correlation between predicted and observed numbers of all taxa was reduced by the effect of subsampling (@fig-richness_op A). The predicted number of taxa was higher than the observed for samples with lower numbers of taxa because more of them had small subsample fractions compared to more taxa-rich samples. The regression of predicted \~ observed + subsample fraction had a higher *R^2^* (0.73). The model predicted EPT richness with high accuracy (*R^2^* 0.92), with a similar albeit smaller effect of subsample fraction (@fig-richness_op B).

The accurate prediction of the data by the model provide confidence in inferences of the experimental effects of interest.

```{r}
#| label: fig-nbinom_me_fit_by_taxon
#| echo: false
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 3.5
#| fig-cap: "a) Correlation coefficients for each taxon of between observed (count in each subsample divided by subsample fraction, log(x + 1)-transformed and averaged for all sample units in each sample) and predicted (P) abundances (mean estimate of log-mean abundances of each taxon in the sample from each site), and b) Slopes of the regression of predicted as a function of observed, both plotted against prevalence of each taxon. Green points indicate taxa for which a non-zero effect of riffle construction was inferred at the 90% confidence level."

# load object predy_draws, calculated above 
load(paste0(model_fit_dir,"fit_riffle_baci_predy_draws.rda"))

# Calculate Observed (mean log-transformed counts per sample) to Expected (predicted mean abundance per sample)
oe_stats <- data.frame(taxoncode = colnames(sdata$c), 
                       cor = NA, slope = NA, adj_r_squ = NA)
for(i in 1:sdata$n_taxa){
  y <- log(exp(apply(predy_draws[[colnames(sdata$c)[i]]],2,FUN = mean)) + 1)
  x <- aggregate(log(sdata$c[,i]/sdata$s[,i] + 1),
                       by = list(site_no = samples$site_no, 
                       sample_no = samples$sample_no,
                       t = samples$t), FUN = mean)$x
  oe_stats$cor[i] <- cor(x,y)
  lmi <- lm(y ~ x)
  oe_stats$adj_r_squ[i] <- summary(lmi)$adj.r.squared
  oe_stats$slope[i] <- coefficients(lmi)[2]
  }

# Calculate prevalence of each taxon by sample
prevalence <- apply(biota_ct, 2, FUN = function(x){sum(x > 0)})
prevalence_by_sample <- data.frame(shortcode = colnames(biota_ct), prev = NA)
for(i in 1:ncol(biota_ct)){
  prevalence_by_sample$prev[i] <- 
    sum(aggregate(biota_ct[,i], by = list(sample_no = samples$sample_no), 
            FUN = function(x) as.numeric(sum(x) > 0))$x)
}

# Find those taxa for which a riffle effect is inferred in the paper and highlight on plot
# (vectors of taxacodes, more_diff_90 and more_sim_90, also used in main paper)
# load objects: (a list predy_cf; and ) a list of lists delta_post, containing lists
# delta_baci1_low, delta_baci2_low, delta_baci1_hi, delta_baci1_hi - see S3 chunk pred_cf
load(paste0(model_fit_dir,"fit_riffle_baci_predy_cf_draws.rda"))

diff_summs <- list()
for(i in 1:length(delta_posts)){
  qlsi <- as.data.frame(do.call(rbind,lapply(delta_posts[[i]],FUN = quantile, 
                                probs = c(0.025,0.05,0.125,0.5,0.875,0.95,0.975))))
  names(qlsi) = c("lo95","lo90","lo75","median","hi75","hi90","hi95")
  meani <- unlist(lapply(delta_posts[[i]],FUN = mean))
  diff_summs[[i]] <- data.frame(shortcode = names(biota_ct), 
                                 mean = meani,
                                 qlsi)
}
names(diff_summs) <- names(delta_posts)
more_diff_90 <- more_diff_95 <- more_sim_90 <- more_sim_95 <- vector()
for(i in 1:length(delta_posts)){
more_diff_90 <- unique(c(more_diff_90,diff_summs[[i]]$shortcode[diff_summs[[i]]$lo90 > 0]))
more_sim_90 <- unique(c(more_sim_90,diff_summs[[i]]$shortcode[diff_summs[[i]]$hi90 < 0]))
}

bgs <- rep(NA, sdata$n_taxa)
bgs[names(biota_ct) %in% unique(c(more_diff_90,more_sim_90))] <- "green"
cols <- bgs; cols[is.na(cols)] <- "black"
layout(matrix(c(1,2,3,3),2,2,byrow=TRUE), widths = c(12,12), heights = c(12,1))
par(mar = c(2,4,1,1))
xpos <- jitter(prevalence_by_sample$prev)
plot(xpos, oe_stats$cor,
     xlim = c(0,53), ylim = c(0,1), pch = 21, bg = bgs,
     axes = FALSE, ylab = "R (O:P)", xlab = "")
abline(h = 1, lty = 3)
axis(1); axis(2, las = 1); box(bty = "l")
title("A.", adj = 0)
plot(xpos, oe_stats$slope,
     ylim = c(0,1.1),pch = 21, bg = bgs,
     axes = FALSE, ylab = "Regression slope (O ~ P)", xlab = "")
abline(h = 1, lty = 3)
axis(1); axis(2, las = 1); box(bty = "l")
title("B.", adj = 0)
par(mar = c(0,0,0,0))
plot.new()
title(xlab = "Prevalence (number of samples with abundance > 0)", line = -1.5)

write.csv(oe_stats, "small_data/riffle_baci_oe_stats.csv", row.names = FALSE)
```

```{r}
#| label: fig-nbinom_pa_stats
#| echo: false
#| warning: false
#| message: false
#| fig-width: 4
#| fig-height: 4
#| fig-cap: "a) Area under the receiver operator characteristic curve (AUC) of predictions of presence-absence from the negative-binomial model for 111 taxa as a function of their prevalence in the 53 samples. AUC could not be calculated for the two taxa that occurred in all samples (Nematoda and Enchytraiedae)."

# load draws of parameters from model (object mod_draws calculated above)
load(paste0(model_fit_dir, "fit_riffle_baci_draws.rda"))

phi_draws <- mod_draws[,grep("phi",names(mod_draws))]
p_mat <- list()
# system.time({
for(t in 1:sdata$n_taxa){
p_mat[[t]] <- predy_draws[[colnames(biota_ct)[t]]]
for(i in 1:ncol(p_mat[[t]]))
p_mat[[t]][,i] <- 1 - pnbinom(0,mu = exp(predy_draws[[colnames(biota_ct)[t]]][,i]),size = phi_draws[t][,1])
}
# }) # ~15 s
names(p_mat) <- colnames(biota_ct)
p_mean <- matrix(nrow = sdata$n_sample, ncol= sdata$n_taxa)
for(t in 1:sdata$n_taxa){
  p_mean[,t] <- apply(p_mat[[t]], 2, FUN = mean)
}

# Function for calculating probability of occurrence in n sample units, given a vector of probabilities, x, of length n
p_per_n <- function(x) {1 - prod(1 - x)} # x, a vector of probabilities

p_mean_per_sample <- matrix(ncol = sdata$n_sample, nrow = sdata$n_taxa)
for(t in 1:sdata$n_taxa){
  for(j in 1:sdata$n_sample){
    p_mean_per_sample[t,j] <- p_per_n(rep(p_mean[j,t],sum(samples$sample_no == j)))
  }}

# Probability of presence in observed data
obs_per_sample <- matrix(ncol = sdata$n_sample, nrow = sdata$n_taxa)
for(t in 1:sdata$n_taxa){
    obs_per_sample[t,] <- aggregate(biota_ct[,t], 
                                     list(sample_no = samples$sample_no), 
                                     FUN = function(y) {sum(y > 0) > 0})$x
  }

library("PresenceAbsence")
pa_stats <- data.frame(shortcode = colnames(biota_ct),
                       taxon = taxa$taxon[match(colnames(biota_ct),taxa$shortcode)], 
                       prevalence = prevalence_by_sample$prev[match(prevalence_by_sample$shortcode, colnames(biota_ct))],
                       PCC = NA,
                       sensitivity = NA, specificity = NA, Kappa = NA, AUC = NA)
for(t in 1:sdata$n_taxa){
  pa_data <- data.frame(taxon = colnames(biota_ct)[t],
                        obs_per_sample[t,],p_mean_per_sample[t,])
  pa_stats[t,-(1:3)] <- presence.absence.accuracy(pa_data)[c("PCC","sensitivity","specificity","Kappa","AUC")] 
}
par(mar = c(4,4,1,1),mfrow = c(1,1))
plot(pa_stats$prevalence, pa_stats$AUC, ylim = c(0.5,1),xlab = "", ylab = "AUC")
title(xlab = "Prevalence (number of samples with abundance > 0)",)

pa_stats <- pa_stats[,names(pa_stats) != "taxon"]
write.csv(pa_stats, "small_data/riffle_baci_pa_stats.csv", row.names = FALSE)
```

```{r}
#| label: fig-richness_op
#| echo: false
#| warning: false
#| message: false
#| fig-width: 7
#| fig-height: 4
#| fig-cap: "Predicted mean number of taxa (A. total, B. Ephemeroptera, Plecoptera and Trichoptera, EPT) in the 53 samples plotted against observed richness. The solid line indicates the 1:1 relationship, and the dashed line the linear regression of predicted as a function of observed.  The R-squared values indicate the adjusted R-squared of the linear regression of predicted ~ observed, and the values in brackets are for the regression predicted ~ observed + s, where s is the mean subsample proportion of the sample. Points are sized by s."

par(mfrow = c(1,2))
par(mar = c(4,4,1,1))
sample_p <- vector("numeric",length = sdata$n_sample)
for(i in 1:sdata$n_sample){
  sample_p[i] <- mean(0.01* samples$subsample_perc[samples$sample_no == i])
}
x <- apply(obs_per_sample,2, FUN = sum)
y <- apply(p_mean_per_sample,2, FUN = sum)
plot(x, y, cex = sample_p + 0.5, axes = FALSE, 
     xlab = "Observed no. taxa", ylab = "Predicted no. taxa")
axis(1); axis(2, las = 1); box(bty = 'l')
abline(0,1)
abline(lm(y ~ x), lty = 3)
r21 <- round(summary(lm(y ~ x))$adj.r.squared,2)
r22 <- round(summary(lm(y ~ x + sample_p))$adj.r.squared,2)
title(main = "A.", adj = 0)
title(main = paste0("  R-sq = ", r21, " (", r22, ")"), 
      adj = 0, line = -1, font.main = 1, cex.main = 1)

x <- apply(obs_per_sample[substr(names(p_mat),1,2) %in% c("QE","QP","QT"),],2, FUN = sum)
y <- apply(p_mean_per_sample[substr(names(p_mat),1,2) %in% c("QE","QP","QT"),],2, FUN = sum)
plot(x, y, cex = sample_p + 0.5, axes = FALSE, 
     xlab = "Observed no. EPT taxa", ylab = "Predicted no. EPT taxa")
axis(1); axis(2, las = 1); box(bty = 'l')
legend("bottomright", pch = 1, pt.cex = c(0.6,1.0,1.5), 
       legend = c(0.1,0.5,1.0),title = "s")
abline(0,1)
abline(lm(y ~ x), lty = 3)
r21 <- round(summary(lm(y ~ x))$adj.r.squared,2)
r22 <- round(summary(lm(y ~ x + sample_p))$adj.r.squared,2)
title(main = "B.", adj = 0)
title(main = paste0("  R-sq = ", r21, " (", r22, ")"), 
      adj = 0, line = -1, font.main = 1, cex.main = 1)

```
